
\section{Introduction}


Causal broadcast~\cite{hadzilacos1994modular} is a fundamental communication
mechanism for numerous distributed protocols and applications (\REF).
% ~\cite{nakamoto2009bitcoin,shapiro2011comprehensive} and
% ~\cite{nedelec2016crate}.
It ensure that all connected processes deliver each broadcast message exactly
once following the happen before
relationship~\cite{lamport1978time,schwarz1994detecting}.

% In large scale and dynamic networks, gossiping constitutes the most efficient mean to
% broadcast messages (\REF): processes build an overlay network by maintaining
% small local view of the network membership (\REF) and each broadcast message
% reach all processes either directly or transitively via forwarding. 

Unfortunately, causal broadcast has proven expensive in in large and dynamic
environments where processes can join, leave, or self-reconfigure at any
time~\cite{charronbost1991concerning}. Table~\ref{table:comparison} shows that
state-of-the-art protocols (\REF) for causal broadcast in dynamic systems are
reactive and induce linear overhead on messages, linear local space consumption,
and linear execution time on delivery. They eventually become overcostly and
inefficient.

% \begin{inparaenum}[(i)]
% \item piggyback preceding messages in new broadcast
%   messages~\cite{birman1987reliable,hadzilacos1993fault},
% \item or maintain and send vector clocks along with new broadcast
%   messages~\cite{fidge1988timestamps,mattern1989virtual}.
% \end{inparaenum}
% Approaches reduce the size of vectors either by
% \begin{inparaenum}[(a)]
% \item maintaining local structures to send the least amount of changing
%   data~\cite{singhal1992efficient}, or by
% % \item relaxing the causal order using probabilistic
% %   structures~\cite{mostefaoui2017probabilistic}, or by
% \item constraining the network topology (\REF).
% \end{inparaenum}
% None of these approaches scales in large and dynamic networks, for
% % they overload each message with linearly increasing data
% % structures. % that depend of the number of processes or the number of messages.
% generated traffic and delivery time of messages increase linearly with the
% number of processes.

% Causal broadcast can be preventive~\cite{friedman2004causal}: processes receive
% messages that are immediately ready for causal delivery. It overloads messages
% with constant size control information, for it uses FIFO communication
% links. Delivery time of messages is constant, for it only discards message
% duplicates. Nothing limits the scalability of the system.  However, these highly
% desirable properties only hold in static environments where processes cannot
% join nor leave nor self-reconfigure. Any change in network membership may lead
% to causal delivery violations. A preventive causal broadcast that generalizes
% these complexity to dynamic networks would finally make causal broadcast
% \TODO{safe}, affordable and efficient in large and dynamic systems.

In this paper, we break the scalability barriers of causal broadcast for large
and dynamic networks. Table~\ref{table:comparison} shows that instead of being
reactive, protocols can be preventive: instead of checking at each receipt if
the message is ready to be delivered, messages arrive ready by design.
% This removes the need for broadcast messages to convey control information.
This difference reduces the complexity of message overhead and delivery
execution time from linear to constant.
% Instead of linear complexity in message overhead and delivery execution time,
% it has constant complexity in the corresponding fields.
However, this preventive approach does not ensure causal order for dynamic
networks.
% only for static networks where no process joins or leaves or self-reconfigures
% over time.
Our contribution is fourfold:
\begin{itemize}
\item We extend the preventive protocol to dynamic settings. Compared to the
  original protocol, it only makes use of temporary buffers of messages to
  ensure that new communication means cannot infringe causal order.
\item We provide the formal proof that our broadcast protocol ensures causal
  order for static and dynamic networks.
\item We provide the complexity analysis of our broadcast
  protocol. Table~\ref{table:comparison} shows that, like the original
  preventive approach, it has constant size overhead on messages, and constant
  delivery execution time.
\item We provide an experimentation highlighting the negative impact of our
  protocol on transmission delays before delivery. It shows that even under bad
  network conditions and high dynamicity, the negative impact remains
  negligible.
\end{itemize}
Consequently, causal broadcast finally becomes an affordable and efficient
middleware for distributed protocols and applications in large and dynamic
networks.

% We propose a uniform reliable broadcast that outperforms state-of-the-art in
% size of broadcast messages, execution time complexity, and local space
% complexity. Our approach belongs to preventive causal broadcast. Message
% overhead is constant. Message delivery time is constant. Local space complexity
% is that of reliable broadcast plus buffers of messages the size of which can be
% bounded.

%% ensures causal delivery without any message overhead.
% To provide causal order, most state-of-the-art approaches are
% reactive~\cite{almeida2008interval,fidge1988timestamps,hadzilacos1993fault,mattern1989virtual,mostefaoui2017probabilistic,singhal1992efficient},
% for they check if message deliveries should be delayed to avoid causality
% violations. On the opposite our approach is
% preventive~\cite{birman1987reliable,friedman2004causal}, for messages are
% immediately delivered on receipt without risk of causality violations.
% We prove that our causal broadcast protocol handles both static and dynamic
% networks. \TODO{Experiment.}
% relies on lightweight assumptions but contrarily to the former, we prove that it
% handles both static and dynamic networks.

% It makes use of FIFO channels (e.g. TCP) and relies on a peer-sampling
% protocol~\cite{jelasity2007gossip} ensuring a network without partitions
% \TODO{Specify that R-broadcast needs this and we need R-broadcast}.  Complexity
% trade-offs such as the number of messages sent by each process, or the number of
% hops before a broadcast message reach all processes, are independent of our
% protocol and only depends of the peer-sampling protocol.

\begin{table}
  \caption{\label{table:comparison} Space and time complexity of causal
    broadcast protocols. 
    $N$ is the number of processes. 
    $W$ is the number of messages received but waiting to be delivered.
    $P$ is the number of messages that are not yet purged.
    $B$ is the size of a set of temporary buffers.}
  \input{input/tableoverlayvstimestamp.tex}
\end{table}

The rest of this paper is organized as follows: Section~\ref{sec:motivations}
shows the background and motivations of our
work. % Section~\ref{sec:preliminaries}
% introduces definitions and theorems about causal
% broadcast.
Section~\ref{sec:proposal} defines our model, describes our proposal, provides
the corresponding proofs, and details the complexity
analysis. Section~\ref{sec:experimentation} shows the results of
experimentation.  Section~\ref{sec:relatedwork} reviews the related work. We
conclude in Section~\ref{sec:conclusion}.


% Broadcast is a communication primitive allowing a process to send a message to
% all other processes in the network. We can add order on message delivery. It
% alleviates the burden of applications to check message relationships. FIFO
% broadcast exists but not so useful. Causal broadcast is very useful; many
% applications require causal order. Holy grail is total order broadcast but not
% scalable, equivalent to consensus.

% We are in point-to-point context.

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../paper"
%%% End:
