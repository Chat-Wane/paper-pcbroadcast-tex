
\section{Introduction}


Broadcasting~\cite{hadzilacos1994modular} is a fundamental communication
mechanism for numerous distributed
protocols~\cite{nakamoto2009bitcoin,shapiro2011comprehensive} and
applications~\cite{nedelec2016crate}. They generally run in highly dynamic
environments where processes can join and leave the network at any
time~\cite{mostefaoui2005static}. Broadcast protocols ensure that all connected
processes receive and deliver each broadcast message.
% A dynamic network~\cite{mostefaoui2005static} comprises interconnected
% processes. Processes can join or leave the network at any moment. Processes can
% communicate with each other. Broadcasting is a communication mean where a
% message sent by a process will reach all other processes of the network.
In this paper, we focus on causal broadcast: the order of message delivery
follows the happen before
relationship~\cite{lamport1978time,schwarz1994detecting}. This alleviates
systems from the burden of tracking causality between its operations.  For
instance, distributed data stores such as Riak, Dynamo, or Cassandra (\REF) and
collaborative editors such as Crate, or Peerpad (\REF) make extensive use of
conflict-free replicated data types (\REF). They feature addition and deletion
of elements. A deletion must follow the corresponding addition, for the sake of
consistency (\REF). Causal broadcast relieves these applications from
continuously checking such constraints.
% For instance, distributed collaborative editors perform deletion immediately,
% for causal broadcast already guaranteed that the message containing the
% corresponding insertion was delivered beforehand.

Unfortunately, causality tracking has proven expensive especially in large and
dynamic networks~\cite{charronbost1991concerning}. Current approaches either
\begin{inparaenum}[(i)]
\item piggyback preceding messages in new broadcast
  messages~\cite{birman1987reliable,hadzilacos1993fault},
\item or maintain and send vector clocks along with new broadcast
  messages~\cite{fidge1988timestamps,mattern1989virtual}.
\end{inparaenum}
More recent approaches focus on reducing the size of vectors either by
\begin{inparaenum}[(a)]
\item maintaining local structures to send the least amount of changing
  data~\cite{singhal1992efficient}, by
\item relaxing the causal order using probabilistic
  structures~\cite{mostefaoui2017probabilistic}, or by
\item constraining the network topology (\REF).
\end{inparaenum}
None of these approaches scales in large and dynamic networks, for they overload
each message with linearly increasing data structures that depend of the number
of processes or the number of messages.

In static networks, causal broadcast does not need to overload messages with any
control information~\cite{friedman2004causal}. It simply makes use of FIFO
communication channels (e.g. TCP) and deterministic overlay networks (\REF) to
disseminate messages. However, it does not handle dynamic networks where
membership changes over time.

In this paper, we break the scalability barrier of causal broadcast for large
and dynamic networks. We propose a uniform reliable broadcast that ensures
causal delivery without any message overhead.  To provide causal order, most
state-of-the-art~\cite{almeida2008interval,birman1987reliable,fidge1988timestamps,hadzilacos1993fault,mattern1989virtual,mostefaoui2017probabilistic,singhal1992efficient}
approaches are reactive, for they check if message deliveries should be delayed
to avoid causality violations. On the opposite our approach is preventive, for
messages are immediately delivered on receipt without risk of causality
violations. We prove that our causal broadcast protocol handles both static and
dynamic networks.

% relies on lightweight assumptions but contrarily to the former, we prove that it
% handles both static and dynamic networks.

% It makes use of FIFO channels (e.g. TCP) and relies on a peer-sampling
% protocol~\cite{jelasity2007gossip} ensuring a network without partitions
% \TODO{Specify that R-broadcast needs this and we need R-broadcast}.  Complexity
% trade-offs such as the number of messages sent by each process, or the number of
% hops before a broadcast message reach all processes, are independent of our
% protocol and only depends of the peer-sampling protocol.

The rest of this paper is organized as follows: Section~\ref{sec:preliminaries}
introduces definitions and theorems about causal
broadcast. Section~\ref{sec:proposal} describes our causal broadcast mechanism,
provides the corresponding proofs and complexity
analysis. Section~\ref{sec:relatedwork} reviews the related work. We conclude in
Section~\ref{sec:conclusion}.


% Broadcast is a communication primitive allowing a process to send a message to
% all other processes in the network. We can add order on message delivery. It
% alleviates the burden of applications to check message relationships. FIFO
% broadcast exists but not so useful. Causal broadcast is very useful; many
% applications require causal order. Holy grail is total order broadcast but not
% scalable, equivalent to consensus.

% We are in point-to-point context.

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../paper"
%%% End:
