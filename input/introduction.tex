
\section{Introduction}


Broadcasting~\cite{hadzilacos1994modular} is a fundamental communication
mechanism for numerous distributed
protocols~\cite{nakamoto2009bitcoin,shapiro2011comprehensive} and
applications~\cite{nedelec2016crate}.  
Broadcast protocols ensure that all connected processes receive and deliver each
broadcast message.
% A dynamic network~\cite{mostefaoui2005static} comprises interconnected
% processes. Processes can join or leave the network at any moment. Processes can
% communicate with each other. Broadcasting is a communication mean where a
% message sent by a process will reach all other processes of the network.
In this paper, we focus on causal broadcast: the order of message delivery
follows the happen before
relationship~\cite{lamport1978time,schwarz1994detecting}. This alleviates
systems from the burden of tracking causality between its operations.

Systems generally run in highly dynamic environments where processes can join
and leave at any time~\cite{mostefaoui2005static}. \TODO{More}

% For instance, distributed data stores such as Riak, Dynamo, or Cassandra (\REF)
% and collaborative editors such as Crate, or Peerpad (\REF) make extensive use of
% conflict-free replicated data
% types~\cite{shapiro2011comprehensive,shapiro2011conflict}. They feature addition
% and deletion of elements. A deletion must follow the corresponding addition, for
% the sake of eventual consistency~\cite{bailis2013eventual}. Causal broadcast
% relieves these applications from continuously checking such constraints.

% For instance, distributed collaborative editors perform deletion immediately,
% for causal broadcast already guaranteed that the message containing the
% corresponding insertion was delivered beforehand.

Unfortunately, accurate causality tracking has proven expensive especially in
large and dynamic networks~\cite{charronbost1991concerning}. Most approaches are
reactive: they check if preceding messages are missing at each receipt and
deliver or delay the message accordingly. They either
\begin{inparaenum}[(i)]
\item piggyback preceding messages in new broadcast
  messages~\cite{birman1987reliable,hadzilacos1993fault},
\item or maintain and send vector clocks along with new broadcast
  messages~\cite{fidge1988timestamps,mattern1989virtual}.
\end{inparaenum}
Approaches reduce the size of vectors either by
\begin{inparaenum}[(a)]
\item maintaining local structures to send the least amount of changing
  data~\cite{singhal1992efficient}, or by
% \item relaxing the causal order using probabilistic
%   structures~\cite{mostefaoui2017probabilistic}, or by
\item constraining the network topology (\REF).
\end{inparaenum}
None of these approaches scales in large and dynamic networks, for
% they overload each message with linearly increasing data
% structures. % that depend of the number of processes or the number of messages.
generated traffic and delivery time of messages increase linearly with the
number of processes.

In static networks, causal broadcast can be
preventive~\cite{friedman2004causal}: processes receive messages that are
immediately ready for causal delivery. It overloads messages with constant size
control information, for it uses FIFO communication links. Delivery time of
messages is constant, for it only discards message duplicates. Nothing limits
the scalability of the system.
% It simply makes use of FIFO communication channels (e.g. TCP) and
% deterministic overlay networks (\REF) to disseminate messages.
However, changes in network membership may lead to causal delivery violations. A
preventive causal broadcast that generalizes these complexity to dynamic
networks would finally make causal broadcast \TODO{safe}, affordable and
efficient in large and dynamic systems.

In this paper, we break the scalability barrier of causal broadcast for large
and dynamic networks. We propose a uniform reliable broadcast that outperforms
state-of-the-art in size of broadcast messages, execution time complexity, and
local space complexity. Our approach belongs to preventive causal
broadcast. Message overhead is constant. Message delivery time is
constant. Local space complexity is that of reliable broadcast plus buffers of
messages the size of which can be bounded.
%% ensures causal delivery without any message overhead.
% To provide causal order, most state-of-the-art approaches are
% reactive~\cite{almeida2008interval,fidge1988timestamps,hadzilacos1993fault,mattern1989virtual,mostefaoui2017probabilistic,singhal1992efficient},
% for they check if message deliveries should be delayed to avoid causality
% violations. On the opposite our approach is
% preventive~\cite{birman1987reliable,friedman2004causal}, for messages are
% immediately delivered on receipt without risk of causality violations.
We prove that our causal broadcast protocol handles both static and dynamic
networks. \TODO{Experiment.}
% relies on lightweight assumptions but contrarily to the former, we prove that it
% handles both static and dynamic networks.

% It makes use of FIFO channels (e.g. TCP) and relies on a peer-sampling
% protocol~\cite{jelasity2007gossip} ensuring a network without partitions
% \TODO{Specify that R-broadcast needs this and we need R-broadcast}.  Complexity
% trade-offs such as the number of messages sent by each process, or the number of
% hops before a broadcast message reach all processes, are independent of our
% protocol and only depends of the peer-sampling protocol.

The rest of this paper is organized as follows: Section~\ref{sec:motivations}
shows the issues and motivations of our work. % Section~\ref{sec:preliminaries}
% introduces definitions and theorems about causal
% broadcast.
Section~\ref{sec:proposal} defines our model, describes our proposal, provides
the corresponding proofs, and details the complexity
analysis. Section~\ref{sec:experimentation} shows the results of
experimentation.  Section~\ref{sec:relatedwork} reviews the related work. We
conclude in Section~\ref{sec:conclusion}.


% Broadcast is a communication primitive allowing a process to send a message to
% all other processes in the network. We can add order on message delivery. It
% alleviates the burden of applications to check message relationships. FIFO
% broadcast exists but not so useful. Causal broadcast is very useful; many
% applications require causal order. Holy grail is total order broadcast but not
% scalable, equivalent to consensus.

% We are in point-to-point context.

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../paper"
%%% End:
