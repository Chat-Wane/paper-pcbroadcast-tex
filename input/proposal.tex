
\section{Causal broadcast for large and dynamic networks}
\label{sec:proposal}

In this section, we introduce a causal broadcast protocol that breaks
scalability barriers for large and dynamic networks. 
% It does not overload
% messages with any control information. 
To provide causal order, most
state-of-the-art~\cite{almeida2008interval,birman1987reliable,fidge1988timestamps,hadzilacos1993fault,mattern1989virtual,mostefaoui2017probabilistic,singhal1992efficient}
approaches are reactive, for they check if message deliveries should be delayed
to avoid causality violations. On the opposite our approach is preventive, for
messages are immediately delivered on receipt without risk of causality
violations. This difference not only removes most of control information
piggybacked in broadcast messages, but also leads to constant delivery
time. Protocols and applications can finally afford causal broadcast in large
and dynamic networks without loss of efficiency.

% This section states  the definitions. It describes our algorithm. It proves that
% it handles both static and dynamic networks. It analyses its complexity.

\subsection{Model}

Definitions and theorems come from~\cite{hadzilacos1994modular}. A network
comprise processes. Processes can communicate with part of the network via
messages. They may not have full knowledge of network membership, for
maintenance costs become too expansive in large and dynamic networks. Instead,
processes build overlay networks with local partial view the size of which is
generally much smaller than the actual network size.

\begin{definition}[Overlay network]
  Just as a network, an overlay network $N$ comprises a set of processes
  $P$. Each Process runs a
  set of instructions sequentially. \\
  An overlay network $N$ also comprises a set of links $E: P \times P$. $p$'s
  neighborhood $Q$ is the set of links departing from $p$. Processes can
  communicate with their neighbors using messages. \\
  Processes are faulty if they crash, otherwise they are correct. The set of
  correct processes is $C$. There are no byzantine processes.
\end{definition}

For the rest of this paper, we will speak of networks and overlay networks
indifferently.

\begin{definition}[Static and dynamic networks]
  A network is static if both its set of processes and its set of edges are
  immutable. Otherwise, the network is dynamic.
\end{definition}

For the rest of the paper, we only consider networks without partitions.

\begin{definition}[Network partition]
  A network has partitions if there exist two correct processes without any path
  between them, i.e., without a link or a sequence of links comprising correct
  processes only.
\end{definition}

%\TODO{Replace ``network'' by  ``distributed system'' ?}

We define time in a logical sense using Lamport's
definition~\cite{lamport1978time}.

\begin{definition}[Happen before]
  Happen before is a transitive, irreflexive, and antisymmetric relation that
  defines a strict partial orders of events. At process $p$, Event $e$ happens
  before -- or precedes -- Event $e'$ is noted $e_p \rightarrow e'_p$. The
  sending of a message $s_p(m)$ always precedes its receipt $r_q(m)$: \\
  $\forall p,\,q \in P, s_p(m) \rightarrow r_q(m)$.
\end{definition}

Processes communicate by sending messages to other processes. They can send
messages to specific processes or all of them.

\begin{definition}[Uniform reliable broadcast]
  A process $p$ can broadcast a message $b_p(m)$, receive a message $r_p(m)$,
  and deliver a message $d_p(m)$.  When a process $p$ broadcasts a message $m$
  to all processes of the network, correct processes eventually receive it: 
  $\forall p \in P,\, (b_p(m) \Leftrightarrow \forall q \in P,\, r_q(m))$. \\
  Uniform reliable broadcast guarantees 3 properties: \\
  \textbf{Validity:} If a correct process broadcasts a message, then it
  eventually
  delivers it: $\forall p \in C,\, b_p(m) \rightarrow d_p(m)$. \\
  \textbf{Uniform Agreement:} If a process -- correct or not -- delivers a
  message,
  then all correct processes eventually deliver it:\\
  $\forall p \in P,\, (d_p(m) \implies \forall q \in C,\, d_q(m))$. \\
  \textbf{Uniform Integrity:} A process delivers a message at most once, and
  only if it was previously broadcast:\\
  $\forall p \in P,\, \neg(d_p(m) \rightarrow d_p(m)) \wedge$\\$d_p(m) \implies
  \exists q \in P,\, b_q(m) \rightarrow d_p(m)$.
\end{definition}

\begin{algorithm}[h]
  \input{./input/algoreliablebroadcast.tex}
  \caption{\label{algo:reliablebroadcast}R-broadcast at Process $p$.}
\end{algorithm}

Algorithm~\ref{algo:reliablebroadcast} shows the instructions of a uniform
reliable broadcast. It uses a structure that keeps track of received messages in
order to deliver them at most once. 
%It uses a peer-sampling protocol that
%provides neighbors to communicate with, i.e., a set of links. 
%%Assuming a network without partitions meaning that there exists at least one
%path from any process to any correct process, then all correct processes
%eventually receive all messages at least once:
Since processes may not have full membership knowledge, processes must forward
broadcast messages. Since the network does not have partitions, processes either
receive the message directly from the broadcaster or transitively. Thus, all
correct processes eventually deliver all messages exactly once. This algorithm
ensures validity, uniform agreement, and uniform integrity.

In addition to reliably conveying messages to all correct processes, broadcast
protocols can ensure that messages are delivered in a specific order.

To order messages broadcast from one process, we define FIFO order.

\begin{definition}[FIFO order]
  If a process broadcasts two messages, processes deliver the first before the
  second:\\
  $\forall p,\,q \in P,\,$\\$b_p(m) \rightarrow b_p(m') \implies d_q(m) \rightarrow
  d_q(m')$.
\end{definition}

To order messages broadcast by different processes, we define local order.

\begin{definition}[Local order]
  If a process broadcasts a message after having delivered another message
  broadcast by another process, processes deliver the later before the former:\\
  $\forall p,\,q,\,r,\, \in P,\,p\neq q,\,$\\$b_p(m) \wedge d_q(m) \rightarrow b_q(m') \implies d_r(m) \rightarrow d_r(m')$.
\end{definition}

To order messages broadcast by every processes, we define causal order.

\begin{definition}[Causal order]
  The delivery order of messages follows the happen before relationships of the
  corresponding broadcasts:\\ $\forall
  p,\,q,\,r \in P,\,$\\$b_p(m) \rightarrow b_q(m') \implies d_r(m) \rightarrow d_r(m')$.
\end{definition}

\begin{theorem}[\label{theo:causal}Causal order equivalence]
%  The intersection of 
  FIFO order and local order is equivalent to causal order.
\end{theorem}

\begin{definition}[Causal broadcast]
  Causal broadcast is a uniform reliable broadcast ensuring causal order.
\end{definition}

% Multiple approaches achieve causal delivery by piggybacking control information
% in broadcast messages (\REF). Upon receipt of messages, processes check if the
% message is ready to be delivered or must be delayed until preceding messages 
% arrive. \TODO{Should I briefly state the limitations? (complexity).}



% Another approach achieves causal delivery without overloading broadcast messages
% with control information (\REF). It only assumes FIFO links and deterministic
% overlay network (\REF). Processes deliver messages as soon as they arrive.

% \begin{definition}[FIFO link]
%   If Process $p$ sends a message $m$ then $m'$ to Process $q$ using a FIFO link,
%   $q$ receives $m$ before $m'$:
%   $s_p(m) \rightarrow s_p(m') \implies r_q(m) \rightarrow r_q(m')$
% \end{definition}


% In this paper, we introduce a causal broadcast protocol that
% \begin{inparaenum}[(i)]
% \item does not convey any control information in broadcast messages, and 
% \item handles both static and dynamic networks.
% \end{inparaenum}


\subsection{Operation}

\begin{algorithm}[h]
  \input{./input/algobufferbroadcast.tex}
  \caption{\label{algo:bufferbroadcast}\CBROADCAST at Process $p$.}
\end{algorithm}

Algorithm~\ref{algo:bufferbroadcast} shows the instructions of our preventive
causal broadcast. Its two operations broadcast and deliver rely on reliable
broadcast (see Algorithm~\ref{algo:reliablebroadcast}). In fact, without
additions nor removals of links, our protocol only executes instructions of
reliable broadcast (see Line~\ref{line:rbroadcast},~\ref{line:rdeliver}).

\begin{theorem}[\CBROADCAST is causal in static networks\label{theo:static}]
  \CBROADCAST is a causal broadcast in static networks.
\end{theorem}

\begin{proof}
  In static networks, \CBROADCAST only executes the instructions of reliable
  broadcast. Reliable broadcast along with FIFO links ensures causal broadcast.
  The proof can be found in Paper~\cite{friedman2004causal}.
\end{proof}


The removal of links and the departure of processes are not an issue, for it
does not reorder messages traveling through the links\footnote{It may create
  partitions infringing the uniform agreement property. Network partitioning
  constitutes an orthogonal problem that we do not address in this
  paper.}. Algorithm~\ref{algo:bufferbroadcast} does not provide specific
instructions for such cases.
% However, it may create partitions. It is an orthogonal problem

\begin{lemma}[\CBROADCAST is causal in dynamic networks subject to
  removals\label{lem:removals}]
  \CBROADCAST is a causal broadcast in dynamic networks where processes can
  leave the network or links can be removed.
\end{lemma}

\begin{proof}
  Removing a process from the network and removing all the incoming and outgoing
  links of this process is equivalent. We assume that removals do not create
  network partitions.  Removing a link does not change the delivery order of
  causally related messages. Identically to the proof of
  Theorem~\ref{theo:static}, our causal broadcast only executes instructions of
  reliable broadcast in such cases. The proof is identical to that of
  Paper~\cite{friedman2004causal}.
\end{proof}

Our causal broadcast becomes more sophisticated when the process adds links.
Figure~\ref{fig:preventiveproblem} shows the issue with link additions.  New
links may act as shortcut for messages. First messages that travel through new
links may arrive before preceding messages that took longer paths. New links
create additional diffusion paths that potentially disorder messages.  Solving
this issue requires that even new links convey all messages in the right
order. Sending all broadcast messages since the beginning would be too
costly. Instead, a process $p$ creating a link to a process $q$ needs to know
the messages received by $q$ to send potentially missing messages in the right
order using this link. While obtaining $q$'s acknowledgment would be costly in
general settings, using already created FIFO links keeps it cheap. Once missing
messages have been sent through this new link, $p$ starts to use it
normally. New links do not create diffusion paths that could break causal order.

Compared to reliable broadcast, Algorithm~\ref{algo:bufferbroadcast} adds a
structure associating each new link with a buffer of messages.  When a process
$p$ wants to use a link to a process $q$ for causal broadcast,
\begin{enumerate}[(i)]
\item it must use the FIFO links already in use to transmit a message to $q$
  and wait for its acknowledgment (see Line~\ref{line:sendlocked}). We leave
  aside the implementation of this send function (e.g. broadcast or
  routing). However, using already established FIFO links constitutes a cheap
  way to achieve it.
\item While awaiting for this acknowledgment, $p$ must buffer each message it
  broadcasts or forwards (see
  Line~\ref{line:bufferbroadcast},~\ref{line:bufferforward}). When $q$ receives
  $p$'s message, it acknowledges it (see Line~\ref{line:sendack}). The message
  it sends can travel through any communication mean.
\item When $p$ receives the acknowledgment from $q$, it uses the FIFO link
  from $p$ to $q$ to send its buffered messages (see
  Line~\ref{line:emptybuffer}). Afterwards, $p$ uses the new link normally.
\end{enumerate}

\begin{lemma}[\CBROADCAST is causal in dynamic networks subject to
  additions\label{lem:additions}]
  \CBROADCAST is a causal broadcast in dynamic networks where processes can join
  the network or links can be added.
\end{lemma}

\begin{proof}
  To prove that \CBROADCAST is a causal broadcast, we must show that it ensures
  validity, uniform agreement, uniform integrity, and causal order -- that is
  FIFO order and local order. \\
  \textbf{Validity, uniform agreement, uniform integrity:} \CBROADCAST is an
  \textsc{R-broadcast}. \\
  \textbf{FIFO:} Suppose a process $p$ broadcasts $m$ before $m'$. Consider that
  a correct process $q$ delivers $m'$. We must show that $q$ delivers $m$ before
  $m'$.  Since adding a FIFO link from a Process $r$ to any other Process $s$ is
  like adding potential FIFO paths from $p$ to $q$, we summarize this as a link
  from $p$ to $q$ with arbitrary settings but still FIFO.  \TODO{Should this be
    a proof?  Maybe a proof of equivalent model if kept}. \\
  Since Process $q$ delivers $m'$ it either received $m'$ from already well
  established links, or from the new one. In the former case, the proof is
  identical to that of Theorem~\ref{theo:static}. In the latter case, Process
  $q$ delivers $m'$ means that Process $p$ broadcasts $m$ then $m'$ either
  \begin{inparaenum}[(i)]
  \item \label{case:one} $m'$ during buffering and $m$ before buffering;
  \item \label{case:two} $m'$ during buffering and $m$ during buffering;
  \item \label{case:three} $m'$ after acknowledgment and $m$ before buffering;
  \item \label{case:four} $m'$ after acknowledgment and $m$ during buffering;
  \item \label{case:five} $m'$ after acknowledgment and $m$ after acknowledgment.
  \end{inparaenum}
  We must show that either 
  \begin{inparaenum}[(1)]
  \item \label{show:one} Process $q$ already received $m$ from another link
    before receiving $m'$ from the new link,
  \item \label{show:two} or that this new link conveyed $m$ before $m'$.
  \end{inparaenum}

  \begin{itemize}
  \item [(\ref{case:one})] Process $p$ put $m'$ in the buffer. Process $p$
    empties the buffer containing $m'$ after $p$ received an acknowledgment
    meaning that at least $m$ has been received at $q$. This
    shows~(\ref{show:one}).
  \item [(\ref{case:two})] Process $p$ put $m$ then $m'$ in the buffer. When the
    acknowledgment is received, it sends $m$ then $m'$ to Process $q$. This
    shows~(\ref{show:two}).
  \item [(\ref{case:three})] Identical to case~(\ref{case:one}) without the need
    of buffering.
  \item [(\ref{case:four})] Since Process $p$ empties the buffer containing $m$
    when it receives the acknowledgment, and since Process $p$ broadcasts $m'$
    afterwards using the new link, it shows~(\ref{show:two}).
  \item [(\ref{case:five})] It directly shows~(\ref{show:two}).
  \end{itemize}
  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  % If Process $p$ broadcasts $m$ before the link addition, Process $p$ either
  % broadcasts $m'$ during buffering phase or after acknowledgment: 
  % \begin{itemize}
  % \item In the former case, since the receipt of $m$ precedes the creation of the
  %   acknowledgement, when $p$ receives the acknowledgement, it empties the buffer
  %   containing $m'$ to $q$. Hence, from any path, Process $q$ receives and
  %   delivers $m$ before $m'$.
  % \item In the later case, the acknowledgement confirms that $q$ received
  %   $m$. Afterwards, when $p$ broadcasts $m'$ it travels, among others, the newly
  %   created link, and eventually arrives to $q$.
  % \end{itemize}
  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  % If Process $p$ broadcasts $m$ during buffering phase, Process $p$ either
  % broadcasts $m'$ during buffering phase or after acknowledgement.
  % \begin{itemize}
  % \item In the former case, $p$ puts $m$ in the buffer before $m'$. When $q$
  %   receives $m'$, either it already received $m$ from another FIFO channel or
  %   it already received $m$ from the emptied buffer that contained $m$ before
  %   $m'$.
  % \item In the later case, When $q$ receives $m'$, either it received $m$ from
  %   FIFO channel or the buffer that empties after acknowledgment.
  % \end{itemize}
  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  % If Process $p$ broadcasts $m$ after acknowledgement, Process $p$ broadcasts
  % $m'$ after acknowledgement. It corresponds to the static network (see proof of
  % Theorem~\ref{theo:static}).
  % In any case, process $q$ delivers $m$ before $m'$. \\
  \textbf{Local:} Since broadcast and forward have identical instructions, the
  proof is identical to that of FIFO order. \\
  % Suppose a process $p$ delivers $m$ before broadcasting $m'$. Consider a
  % correct process $q$ that delivers $m'$. We must show that $q$ delivers $m$
  % before $m'$. Just as the proof for Theorem~\ref{theo:static}, the difference
  % in our Algorithm compared to FIFO order demonstration is that Process $q$ may
  % have already received -- or is the origin of the broadcast of --
  % $m$. \TODO{Not over}  
  \textbf{Causal:} From Theorem~\ref{theo:causal}, since \CBROADCAST ensures
  both FIFO order and local order, it ensures causal order.
\end{proof}

\begin{theorem}[\CBROADCAST is a causal broadcast]
  \CBROADCAST is a causal broadcast in both static and dynamic network settings.
\end{theorem}

\begin{proof}
  For static networks, it comes from Theorem~\ref{theo:static}. For dynamic
  networks, it comes from Lemmas~\ref{lem:removals}~and~\ref{lem:additions}.
\end{proof}

% Broadcast does not overload messages with any control information. However, this
% does not hold in dynamic networks.

% In dynamic networks, processes can leave the network or join it at any time.
% They also can remove or add links to other processes. For causal broadcast,
% leaving the network is equivalent to link removals; joining the network is
% equivalent to link additions. It simply removes or adds potential diffusion
% paths.

% Link removals are not an issue as long as it does not partition the network: the
% order of message deliveries remains unchanged. However, link additions are
% problematic.  The issue is that 



% Keeping the algorithm preventive allows to broadcast messages without
% overloading them.
% The idea is to use already established FIFO links to acknowledge the receipt of
% messages at a marginal cost. The process knows the potentially missing
% messages. It sends them in the right order using the new FIFO link, then it
% starts using it normally. Consequently, new links do not create diffusion paths
% breaking causal order.


% \begin{figure}
%   \begin{center}
%     \input{./input/figsolved.tex}
%     \caption{\label{fig:solved}\CBROADCAST in dynamic networks. $m'$ cannot
%       precede $m$. $p_2$'s deliveries remain hidden for the sake of clarity.}
%   \end{center}
% \end{figure}

% \EXAMPLE{Example without buffer.}{Figure~\ref{fig:solved} shows how our
% algorithm solves causal order violations. Similarly to Figure~\ref{fig:problem},
% a FIFO channel links $p_1$ to $p_2$; another links $p_2$ to $p_3$; none links
% $p_1$ to $p_3$. Process $p_1$ broadcasts $m$. Then $p_1$ wishes to create a link
% to $p_3$. It sends a message to $p_3$ using its FIFO links. Thus, $m$ precedes
% this message at $p_3$. When $p_3$ acknowledges this message to $p_1$ using any
% communication way, the later knows that it $p_3$ received and delivered at least
% $m$. Hence, all subsequent broadcast from $p_1$ can use the new communication
% link safely. When $p_1$ broadcasts $m'$, there exist no path where $m'$ arrives
% before $m$.}

% \begin{figure}
%   \begin{center}
%     \input{./input/figbuffer.tex}
%     \caption{\label{fig:buffer}Role of the buffer in \CBROADCAST during link
%       addition. $m''$ cannot precede $m'$. $p_2$'s deliveries remain hidden for
%       the sake of clarity.}
%   \end{center}
% \end{figure}

% \EXAMPLE{Example with buffer.}{The previous example does not depict the
% buffer usage. The buffer becomes useful when a process broadcasts or forwards a
% message between the opening of a link and the receipt of the corresponding
% acknowledgment. Figure~\ref{fig:buffer} shows an example where a process uses a
% buffer to ensure causal delivery of messages. Process $p_1$ connects to Process
% $p_3$. Between the departure of the $locked$ message and the arrival of the
% acknowledgment, $p_1$ broadcasts a message $m'$. Network conditions
% delay the arrival of this message from $p_2$ to $p_3$ such that when Process
% $p_1$ broadcasts another message $m''$, $m'$ is not yet arrived via
% $p_2$. Fortunately, since $p_1$ buffered $m'$ and sent it after acknowledgment,
% Process $p_3$ receives and delivers $m'$ before $m''$.}

\begin{figure*}
  \begin{center}
    \subfloat[Part A][Process~A broadcasts $a$.]
    {\input{./input/figpreventivesolveA.tex}}
    \hspace{20pt}
    \subfloat[Part B][Process~A wants to add a link to Process~D. 
    It sends a locked message $\ell$ to Process~D using one of its FIFO links.]
    {\input{./input/figpreventivesolveB.tex}}
    \hspace{20pt}
    \subfloat[Part C][Process~A broadcasts $a'$.
    It does not send it through the new link but buffers it.]
    {\input{./input/figpreventivesolveC.tex}}
    \hspace{20pt}
    \subfloat[Part D][Process~D receives $\ell$ and acknowledges it to $A$.
    The acknowledgment message $\alpha$ can travel by any communication
    mean.]
    {\input{./input/figpreventivesolveD.tex}}
    \hspace{20pt}
    \subfloat[Part E][Process~A receives Process~D's acknowledgment. 
    The former safely empties its buffer to Process~D. 
    Using the new link cannot cause causal order violation anymore.]
    {\input{./input/figpreventivesolveE.tex}}
    \caption{\label{fig:preventivesolve}Preventive causal broadcast does not violate
      causal order in dynamic networks anymore.}
  \end{center}
\end{figure*}




\begin{algorithm}
  \input{input/algoboundingbuffer.tex}
  \caption{\label{algo:boundingbuffer}Bounding the size of buffers and handling
    network failures.}
\end{algorithm}

While Algorithm~\ref{algo:bufferbroadcast} ensures causal order of message
deliveries, buffers consume unbounded space. For instance, if the message
acknowledging the locked message fails to reach its destination, the
corresponding buffer continues to grow over broadcast and forwarded messages. 

Algorithm~\ref{algo:boundingbuffer} aims to bound the size of buffers and handle
network failures, i.e., crashed processes or lost messages. Now, our causal
broadcast can reset the buffer of a new link. Resets happen when either the
buffer size is above a threshold (see Line~\ref{line:maxsize}), or the
acknowledgment message took too long to come back (see
Line~\ref{line:timeout}). Each locked message has an identifier corresponding to
a link. When a process receives an acknowledgment, it knows if it expired due to
a timeout. We only keep the buffer corresponding to the latest locked
message. We bound the number of retries so the protocol does not stay stuck in a
loop of retries.

\TODO{Example of failure management? (Will not look nice).}

% \begin{algorithm}
%   \input{input/algosendfunctions.tex}
%   \caption{\label{algo:sendfunctions}Implementation of sending functions in
%     neighbor-to-neighbor peer-sampling protocols.}
% \end{algorithm}


%% \subsection{Proofs}

%% This section provides the proofs that our approach work in both static and
%% dynamic networks.



\subsection{Complexity}
\label{subsec:complexity}

We review and discuss about the complexity of \CBROADCAST. We distinguish the
complexity of causal ordering, the complexity of reliable broadcast, and the
complexity brought by the overlay network.

\PAR{Causal ordering.}{Regarding traffic, broadcast messages do not need to
  convey any control information. However, processes must send each message to
  all their neighborhood exactly once. It creates as many copies as
  neighbors. This number of copies may constitute an issue when the size of
  messages is large. To solve this issue, processes can send identifiers instead
  of large messages then send these messages on demand.  It introduces
  additional delays in communications but greatly reduces generated traffic
  (\REF).  Regarding local space consumption, our protocol maintains one buffer
  per link during its acknowledgment time. We assume that this time is short so
  the number of buffered messages stays small. Network conditions can make this
  assumption false. Algorithm~\ref{algo:boundingbuffer} allows to bound the size
  of each buffer and handle network failures.}

% While Algorithm~\ref{algo:bufferbroadcast} shows no buffer management which
% means that they can grow unbounded, we can easily bound them. For instance,
% above a threshold we clear the buffer and send another locked message, or we
% remove the link altogether.

\PAR{Reliable broadcast.}{Algorithm~\ref{algo:reliablebroadcast} shows the
  instructions of reliable broadcast. Even in presence of message duplicates it
  avoids multiple deliveries of a same message. To achieve this, the most
  straightforward structure is a set saving all new received messages. However,
  it increases linearly with the number of delivered messages (\REF). Assigning
  a unique identifier $\langle p,\, counter \rangle$ to each message changes the
  complexity. It becomes a vector that increases linearly with the number of
  processes that ever broadcast a message~\cite{fidge1988timestamps}. Using
  interval tree clocks~\cite{almeida2008interval} slightly overloads messages
  with identifiers but it improves the space complexity: the local structure
  increases linearly with the number of processes that are currently involved in
  broadcasting.}


% \TODO{Rework.} Represented in Algorithms~\ref{algo:fifobroadcast}
% and~\ref{algo:bufferbroadcast} by Function $alreadyReceived$. Causal ordering
% and detecting duplicated receipts are orthogonal problems. In this paper, we do
% not provide an implementation for the later. The simplest approach consists in
% saving all received messages (\REF). However, the size of this set linearly and
% monotonically increases as the number of broadcast messages increases. One would
% prefer an approach based on vectors where one entry corresponds to the number of
% messages received by a particular process~\cite{fidge1988timestamps}. Such
% approach do not require to piggyback additional data in the message. However, it
% requires to store locally a vector the size of which increases linearly compared
% to the number of processes that ever broadcast a message. Interval tree
% clocks~\cite{almeida2008interval} allow processes to reduce this complexity. It
% becomes linear in terms of number of processes that are currently involved in
% broadcasting. Possible improvements could take advantage of the fact that the
% number of duplicates is equal to the number of incoming links. However, it does
% not hold in dynamic networks where additional links are established. Finding a
% sublinear bound for detecting duplicated receipts remains an open problem.


\PAR{Overlay network.}{Values such as the number of messages sent by each
  process, or the number of hops for a message to reach all processes, are
  interdependent values brought by the overlay network. For instance, random
  peer-sampling protocols~\cite{jelasity2007gossip} build network overlays with
  properties similar to those of random graphs~\cite{erdos1959random}. They
  provide each process with a random subset of neighbors the size of which is
  considerably smaller than the network size. Since the neighborhood size is
  logarithmic compared to the network size, the number of messages sent by each
  process for each broadcast message is logarithmic.  Since random peer-sampling
  protocols build topologies close to random graphs, messages take a logarithmic
  number of hops to reach all processes. In addition, random peer-sampling
  protocols such as \SPRAY~\cite{nedelec2017adaptive} or
  \CYCLON~\cite{voulgaris2005cyclon} create links using only
  neighbor-to-neighbor interactions, i.e., they establish links only two hops
  apart. It takes only 4 hops for a new link to get acknowledged.  The overhead
  brought by these messages is negligible. The acknowledgment time of buffers,
  hence the size of buffers, remains small.}

The next section reviews state-of-the-art techniques designed to maintain causal
order among messages.

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../paper"
%%% End:
