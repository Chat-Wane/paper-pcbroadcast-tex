
\section{Causal broadcast}
\label{sec:proposal}

We propose an approach guaranteeing causal order to uniform reliable
broadcasts. It only makes use of FIFO communication channels (e.g. TCP), and
relies on scalable peer-sampling protocols that must not create network
partitions (e.g. \SPRAY~\cite{nedelec2017adaptive}, or
\CYCLON~\cite{voulgaris2005cyclon}).

Section~\ref{subsec:fifobroadcast} starts by showing that FIFO-based broadcast
is sufficient to provide causal delivery of messages. This result holds if the
network is static or links are removed only. It does not hold if links are added
to the network. Section~\ref{subsec:bufferbroadcast} provides a simple algorithm
that solves this issue. It allows processes to use a causal broadcast which
alleviates applications of the burden of tracking causal relationships.

\subsection{FIFO-based causal broadcast}
\label{subsec:fifobroadcast}

The FIFO-based causal broadcast relies on a peer-sampling protocol. It provides
a set of neighbors to communicate with via FIFO channels. The peer-sampling
protocol must ensure that the network is not partitioned.

\begin{definition}[FIFO communication channel]
  If Process $p$ sends a message $m$ then $m'$ to Process $q$ using a FIFO
  channel, $q$ receives $m$ before $m'$.
\end{definition}

\begin{algorithm}[h]
  \input{./input/algofifobroadcast.tex}
  \caption{\label{algo:fifobroadcast}FBC-broadcast.}
\end{algorithm}

Algorithm~\ref{algo:fifobroadcast} shows the instructions of the causal
broadcast mechanism built using FIFO channels. Functions $\textsc{broadcast}$
and $\textsc{forward}$ are distinct although holding the same instructions to
highlight that only 1 process broadcasts while all other processes
forward. Function $\textsc{receive}$ makes sure that each process forwards each
message exactly once. Function $\textsc{alreadyReceived}$ checks if a message
has already been received by the process. We voluntarily keep the implementation
out of this paper, for it constitutes an orthogonal problem. It is worth noting
that this feature is achievable without overhead in terms of message size.

\begin{definition}[Static network]
  A network is static if it comprises an unmutable set of edges and an unmutable
  set of processes.
\end{definition}

% \paragraph{Static networks.} A network is a set of processes linked by a set
% of channels. In a static network, processes cannot fail nor leave, and links
% cannot be created nor removed. In this context, FIFO channels are sufficient
% to provide causal ordering of messages.

\begin{theorem}[\label{theo:static}FBC-broadcast in static networks is causal]
  Assuming a static network without partitions, FBC-broadcast is causal.
\end{theorem}

\begin{proof} \TODO{Prove validity, uniform agreement, uniform integrity?} To
  prove causal ordering, we must show that such broadcast provides both FIFO
  ordering and Local ordering of messages. \\
  \textbf{FIFO:} Suppose a process $p$ broadcasts $m$ before $m'$. Consider that
  a correct process $q$ delivers $m'$. We must show that $q$ delivers $m$ before
  $m'$. Process $p$ broadcast message $m$ before broadcasting $m'$ to all its
  neighborhood using FIFO channels. Each neighbor eventually receives and
  delivers $m$ then $m'$. Each neighbor forwards each message exactly once in
  the order they delivered them to all its neighbors using FIFO channels. Since
  we assume a network without clusters, messages reach all processes. Process
  $q$ eventually receives and delivers $m$ first, then it eventually receives
  and delivers $m'$. \\
  \textbf{Local:} Suppose a process $p$ delivers $m$ before broadcasting
  $m'$. Consider a correct process $q$ that delivers $m'$. We must show that $q$
  delivers $m$ before $m'$. Since $p$ delivers $m$ before broadcasting $m'$, it
  forwards $m$ to all its neighbors before broadcasting $m'$ to the same
  neighbors. Similarly to FIFO ordering, due to the use of FIFO channels, the
  forwardings, and the absence of network clusters, Process $q$ already received
  or eventually receives $m$ when it receives $m'$. Thus, it delivers $m$ before
  delivering $m'$. \\
  \textbf{Causal:} From Theorem~\ref{theo:causal}, since FBC-broadcast ensures
  both FIFO ordering and Local ordering, it ensures Causal ordering.
\end{proof}


\begin{figure}
  \begin{center}
    \input{./input/figstatic.tex}
    \caption{\label{fig:static}FIFO channels are sufficient to provide causal
      order in static networks.}
  \end{center}
\end{figure}

\paragraph{\emph{Example.}}Figure~\ref{fig:static} shows FBC-broadcast solves
the causal order violation from Figure~\ref{fig:generalproblem} by using FIFO
channels.  The figure shows a static network comprising 3 processes $p_1$,
$p_2$, and $p_3$ linked to each other. The figure does not show messages sent by
$p_3$ for the sake of clarity.  The processes receive $m$ and $m'$ multiple
times but there exist no link in the paths from $p_2$ to $p_3$ that carries $m'$
without having carried $m$ beforehand. Hence, the delivery of $m$ always
precedes the delivery of $m'$ at any process.

% \paragraph{Dynamic networks.} Removing a channel does not impair causal
% ordering of messages except if it generates network
% partitions. \TODO{Theorem.}

\begin{definition}[Dynamic network]
  A network is dynamic if it comprises a mutable set of edges and a mutable set
  of processes.
\end{definition}

\begin{theorem}[FBC-broadcast in dynamic networks subject to link removal is
  causal]
  As long as the network is not partitioned, FBC-broadcast remains causal when
  the number of links in the network is monotonically decreasing.

%%  \TODO{In fact, it
%%    remains causal even when partitionned. But uniform agreement is violated.}
\end{theorem}

\begin{proof}
  Removing a link does not change the delivery order of causally related
  messages. Proof of Theorem~\ref{theo:static} about causal order holds.
  However, removing a link may create network partitions. In such case, a
  message may not reach all processes. FBC-broadcast still ensures causal order,
  but uniform agreement is violated.
  % Consider Process $p$ belongs to partition $A$, Process $q$ belongs to
  % partition $B$. Messages broadcast by processes of Partition $A$ reach
  % processes of Partition $B$, but not the converse, assuming links are
  % unidirectional. Processes $p$ broadcasts a message $m$ received and delivered
  % by $q$. Then $q$ broadcasts a message $m'$
  % As long as the removal of links do not partition the network, messages reach
  % all processes. The proof is therefore identical to that of
  % Theorem~\ref{theo:static}.
\end{proof}

\begin{theorem}[\label{theo:removals}FBC-broadcast in dynamic network subject to link additions is
  not causal]
  Using FBC-broadcast, adding links to the network may lead to causal order
  violations.
\end{theorem}

\begin{figure}
  \begin{center}
    \input{./input/figproblem.tex}
    \caption{\label{fig:problem}Adding a FIFO channel endangers causal
      ordering.}
  \end{center}
\end{figure}

\begin{proof}
  Figure~\ref{fig:problem} illustrates the issue with the establishment of new
  FIFO channels. In this example, a FIFO channel links $p_1$ to $p_2$; another
  links $p_2$ to $p_3$; none links $p_1$ to $p_3$. Other FIFO channels may exist
  but we do not show them for the sake of simplicity. Process $p_1$ broadcasts
  $m$ and delivers it. $p_3$ receives it by the intermediary of $p_2$. In the
  meantime, $p_1$ creates a FIFO channel to $p_3$, then broadcasts $m'$ to $p_2$
  and $p_3$. Since the path through $p_2$ is longer in terms of propagation time
  compared to the direct connections from $p_1$ to $p_3$, Process $p_3$ receives
  and delivers $m'$ before $m$. It violates causal order, for $m'$ precedes $m$.
\end{proof}

Handling dynamic networks is mandatory for causal broadcast
mechanisms. Unfortunately, FBC-broadcast fails when links are added to the
network. Staying with the principle of FIFO-based broadcast, we extend
FBC-broadcast to fully handle dynamic networks. The solution is lightweight and
only uses local knowledge.

\subsection{FIFO-based causal broadcast+}
\label{subsec:bufferbroadcast}

Analysing the issue with link additions, we see that new links can act as a
shortcut for messages. This creates gaps in the causal delivery, i.e., messages
that should be delivered are still missing.  FIFO-based causal broadcast$^+$
aims to ensure that these gaps are filled consistently. The idea is to use
already established broadcasting network.


Solving the issue requires 3 steps. When a process $p$ wants to use a link to a
process $q$ for causal broadcast,
\begin{enumerate}[(i)]
\item it must use the FIFO channels already in use to transmit a message to $q$
  awaiting for its acknowledgment.
\item While awaiting for this acknowledgment, $p$ buffers each message it
  sends.
\item When $p$ receives the acknowledgment from $q$, it uses the FIFO channel
  from $p$ to $q$ to send its buffered messages. Afterwards, the channel is
  ready to be used for causal broadcast.
\end{enumerate}

\begin{algorithm}[h]
  \input{./input/algobufferbroadcast.tex}
  \caption{\label{algo:bufferbroadcast}FBC-broadcast$^+$.}
\end{algorithm}


Algorithm~\ref{algo:bufferbroadcast} shows the instructions of our improved
FIFO-based causal broadcast. Similarly to Algorithm~\ref{algo:fifobroadcast},
each process has a set of neighbors to communicate with via FIFO
channels. Messages transitively reach all processes using forwarding. Processes
deliver and forward each message exactly once.  

Compared to Algorithm~\ref{algo:fifobroadcast}, it adds a structure associating
each opening channel with a buffer of messages. When Process $p$ gets notified
that another FIFO channel to Process $q$ is available, it associates this
channel with an empty buffer of messages. It also sends a \emph{locked} message
to $q$. We leave aside the implementation of this send function (e.g. broadcast
or routing), but it must use the FIFO channels already in use.  Process $p$ does
not use the new links until Process $q$ confirmed the receipt of the locked
message. Acknowledgements do not have to travel through FIFO channels.  Once it
receives the acknowledgment, $p$ empties the buffer of messages to $q$ and start
using the channel normally.

\begin{theorem}[FBC-broadcast$^+$ is causal]
  In both static and dynamic networks, FBC-broadcast$^+$ is causal.
\end{theorem}

\begin{proof}
  For static and dynamic networks with link removals, the proof is identical to
  that of Theorems~\ref{theo:static} and~\ref{theo:removals}, for the buffers do
  not activate in such instances. For dynamic networks with link additions, we
  must show that FBC-broadcast$^+$ ensures both
  FIFO order and Local order. \\
  \textbf{FIFO:} \TODO{meow} \\
  \textbf{Local:} \TODO{miaw} \\
  \textbf{Causal:} From Theorem~\ref{theo:causal}, since FBC-broadcast$^+$
  ensures both FIFO ordering and Local ordering, it ensures Causal ordering.
\end{proof}

\begin{figure}
  \begin{center}
    \input{./input/figsolved.tex}
    \caption{\label{fig:solved}Causal broadcast in dynamic networks. \TODO{not
        done yet.}}
  \end{center}
\end{figure}

\paragraph{\emph{Example.}} Figure~\ref{fig:solved} shows how our algorithm solves
causal order violations. Similarly to Figure~\ref{fig:problem}, a FIFO channel
links $p_1$ to $p_2$; another link $p_2$ to $p_3$; none links $p_1$ to
$p_3$. Process $p_1$ broadcasts $m$. Then $p_1$ wishes to create a link to
$p_3$. It sends a message to $p_3$ using its FIFO channels. Thus, this message
will follow $m$ at $p_3$. When $p_3$ acknowledges this message to $p_1$, the
later knows that it receives at least $m$. \TODO{Not done.}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../paper"
%%% End:
