
\section{Causal broadcast for large and dynamic networks}
\label{sec:proposal}

In this section, we introduce a causal broadcast protocol that breaks
scalability barriers for large and dynamic networks. 
% It does not overload
% messages with any control information. 
To provide causal order, most
state-of-the-art~\cite{almeida2008interval,birman1987reliable,fidge1988timestamps,hadzilacos1993fault,mattern1989virtual,mostefaoui2017probabilistic,singhal1992efficient}
approaches are reactive, for they check if message deliveries should be delayed
to avoid causality violations. On the opposite our approach is preventive, for
messages are immediately delivered on receipt without risk of causality
violations. This difference removes the need for messages to convey any control
information. The local space complexity brought by causal ordering remains
small.  Protocols and applications can finally afford causal broadcast in large
and dynamic networks.

This section describes our algorithm. It proves that it handles both static and
dynamic networks. It analyses its complexity.

% \subsection{2-processes equivalent model}

% \begin{figure}
%   \begin{center}
%     \input{./input/fig2eqmodel.tex}
%     \caption{\label{fig:2eqmodel}2-processes equivalent of a broadcast from any
%       process to any other.}
%     \end{center}
% \end{figure}

% \TODO{Maybe not here or maybe remove.}

% When a process broadcasts a message, processes receiving it forward it exactly
% once. Messages may be received multiple times by a process depending on the
% peer-sampling protocol. They receive as many duplicated messages as they have
% incoming links.  Considering only the process that sent the message that led to
% a forwarding as parent, we can build a directed acyclic graph using the paths
% taken by messages from the origin of the broadcast to any process.

% Figure~\ref{fig:2eqmodel} shows the equivalent model with 2 processes. Channels
% of arbitrary speed convey messages from Process $p_{from}$ to Process
% $p_{to}$. When Process $p_{to}$ sends a message, it sends it through all
% links. Even though they have different speeds that may change at arbitrary time,
% if channels are FIFO, Process $p_{to}$ will receive messages in the same order as
% Process $p_{from}$ sent them.


% \subsection{FIFO-based causal broadcast}
% \label{subsec:fifobroadcast}

% Algorithm~\ref{algo:reliablebroadcast} shows the instructions of a uniform
% reliable broadcast. It relies on a peer-sampling protocol that provides links to
% communicate with other processes. When these links are FIFO, the broadcast
% becomes causal under certain conditions.

% \begin{definition}[Static network]
%   A network is static if it comprises an immutable set of edges and an immutable
%   set of processes.
% \end{definition}

% \paragraph{Static networks.} A network is a set of processes linked by a set
% of channels. In a static network, processes cannot fail nor leave, and links
% cannot be created nor removed. In this context, FIFO channels are sufficient
% to provide causal ordering of messages.

% \begin{theorem}[\label{theo:static}FBC-broadcast in static networks is causal]
%   Assuming a static network without partitions, FBC-broadcast is causal.
% \end{theorem}

% \begin{proof}
%   To prove that FBC-broadcast is causal, we must show that it ensures validity,
%   uniform agreement, uniform integrity, and causal order -- that is FIFO order
%   and local order. \\
%   \textbf{Validity, uniform agreement, uniform integrity:} FBC-broadcast is an
%   R-broadcast. \\
%   \textbf{FIFO:} Suppose a process $p$ broadcasts $m$ before $m'$. Consider that
%   a correct process $q$ delivers $m'$. We must show that $q$ delivers $m$ before
%   $m'$. \\
%   Since the peer-sampling protocol ensures that the network is not partitioned,
%   since each process receiving a message forwards it exactly once to all its
%   neighborhood, each message eventually reaches all processes and each link
%   conveys all messages exactly once. \\
%   Since each process forwards each message in a FIFO manner, since messages
%   travel using FIFO channels, and since each channel conveys all messages
%   exactly once, they convey the messages in the order they were broadcast. \\
%   Since Process $p$ broadcasts $m$ before $m'$, and since Process $q$ delivers
%   $m'$, Process $q$ received $m$ before $m'$. \\
%   Since processes deliver messages in the order they received them, Process $q$
%   delivered $m$ before $m'$. \\
%   \textbf{Local:} Suppose a process $p$ delivers $m$ before broadcasting
%   $m'$. Consider a correct process $q$ that delivers $m'$. We must show that $q$
%   delivers $m$ before $m'$. \\
%   Since broadcast and forward have identical instructions, we add to ``processes
%   receive the messages in the order they were broadcast'' the statement ``if a
%   process forwards a message before broadcasting one, processes will receive the
%   forwarded message before the broadcast one'' and converse. \\
%   Since Process $q$ delivers $m'$, channels from which it receives $m'$ already
%   conveyed $m$. Since processes deliver messages in the order they received
%   them, Process $q$ delivers $m$ before $m'$. \\
%   \textbf{Causal:} From Theorem~\ref{theo:causal}, since FBC-broadcast ensures
%   both FIFO ordering and local ordering, it ensures causal ordering.
% \end{proof}


% \begin{figure}
%   \begin{center}
%     \input{./input/figstatic.tex}
%     \caption{\label{fig:static}FIFO channels are sufficient to provide causal
%       order in static networks.}
%   \end{center}
% \end{figure}

% \paragraph{\emph{Example.}} Figure~\ref{fig:static} shows FBC-broadcast solves
% the causal order violation from Figure~\ref{fig:generalproblem} by using FIFO
% channels.  The figure shows a static network comprising 3 processes $p_1$,
% $p_2$, and $p_3$ linked to each other. The figure does not show messages sent by
% $p_3$ for the sake of clarity.  The processes receive $m$ and $m'$ multiple
% times but there exists no link in the paths from $p_2$ to $p_3$ that carries $m'$
% without having carried $m$ beforehand. Hence, the delivery of $m$ always
% precedes the delivery of $m'$ at any process.

% \begin{definition}[Dynamic network]
%   A network is dynamic if it comprises a mutable set of edges and a mutable set
%   of processes.
% \end{definition}

\subsection{Operation}

Reliable broadcast (see Algorithm~\ref{algo:reliablebroadcast}) along with FIFO
links allows causal delivery of broadcast messages at no
cost~\cite{friedman2004causal}. Broadcast does not overload messages with any
control information. However, this does not hold in dynamic networks.

In dynamic networks, processes can leave the network or join it at any time.
They also can remove or add links to other processes. For causal broadcast,
leaving the network is equivalent to link removals; joining the network is
equivalent to link additions. It simply removes or adds potential diffusion
paths.

Link removals are not an issue as long as it does not partition the network: the
order of message deliveries remains unchanged. However, link additions are
problematic.  The issue is that new links may act as shortcut for
messages. First messages that travel through new links may arrive before
preceding messages that took longer paths. New links create additional diffusion
paths that potentially disorder messages. 

Solving this issue requires that even new links convey all messages in the right
order. Sending all broadcast messages since the beginning would be too
costly. Instead, a process $p$ creating a link to a process $q$ needs to know
the messages received by $q$ to send potentially missing messages in the right
order using this link. While obtaining $q$'s acknowledgment would be costly in
general settings, using already created FIFO links keeps it cheap. Once missing
messages have been sent through this new link, $p$ starts to use it
normally. New links do not create diffusion paths that could break causal order.

% Keeping the algorithm preventive allows to broadcast messages without
% overloading them.
% The idea is to use already established FIFO links to acknowledge the receipt of
% messages at a marginal cost. The process knows the potentially missing
% messages. It sends them in the right order using the new FIFO link, then it
% starts using it normally. Consequently, new links do not create diffusion paths
% breaking causal order.

\begin{algorithm}[h]
  \input{./input/algobufferbroadcast.tex}
  \caption{\label{algo:bufferbroadcast}\CBROADCAST at Process $p$.}
\end{algorithm}

Algorithm~\ref{algo:bufferbroadcast} shows the instructions of \CBROADCAST. 
% It solves the dynamic network issues in 3 steps.  
Compared to Algorithm~\ref{algo:reliablebroadcast}, it adds a structure
associating each opening link with a buffer of messages.  When a process $p$
wants to use a link to a process $q$ for causal broadcast,
\begin{enumerate}[(i)]
\item it must use the FIFO links already in use to transmit a message to $q$
  and wait for its acknowledgment (see Line~\ref{line:sendlocked}). We leave
  aside the implementation of this send function (e.g. broadcast or
  routing). However, using already established FIFO links constitutes a cheap
  way to achieve it.
\item While awaiting for this acknowledgment, $p$ must buffer each message it
  broadcasts or forwards (see
  Line~\ref{line:bufferbroadcast},~\ref{line:bufferforward}). When $q$ receives
  $p$'s message, it acknowledges it (see Line~\ref{line:sendack}). The message
  it sends can travel through any communication mean.
\item When $p$ receives the acknowledgment from $q$, it uses the FIFO link
  from $p$ to $q$ to send its buffered messages (see
  Line~\ref{line:emptybuffer}). Afterwards, $p$ uses the new link normally.
\end{enumerate}

\begin{figure}
  \begin{center}
    \input{./input/figsolved.tex}
    \caption{\label{fig:solved}\CBROADCAST in dynamic networks. $m'$ cannot
      precede $m$. $p_2$'s deliveries remain hidden for the sake of clarity.}
  \end{center}
\end{figure}

% \begin{figure}
%   \begin{center}
%     \input{./input/figeq2solved.tex}
%     \caption{\label{fig:eq2solved}2-processes equivalent of Figure~\ref{fig:solved}.}
%   \end{center}
% \end{figure}

\paragraph{\emph{Example without buffer.}} Figure~\ref{fig:solved} shows how our
algorithm solves causal order violations. Similarly to Figure~\ref{fig:problem},
a FIFO channel links $p_1$ to $p_2$; another links $p_2$ to $p_3$; none links
$p_1$ to $p_3$. Process $p_1$ broadcasts $m$. Then $p_1$ wishes to create a link
to $p_3$. It sends a message to $p_3$ using its FIFO links. Thus, $m$ precedes
this message at $p_3$. When $p_3$ acknowledges this message to $p_1$ using any
communication way, the later knows that it $p_3$ received and delivered at least
$m$. Hence, all subsequent broadcast from $p_1$ can use the new communication
link safely. When $p_1$ broadcasts $m'$, there exist no path where $m'$ arrives
before $m$.

\begin{figure}
  \begin{center}
    \input{./input/figbuffer.tex}
    \caption{\label{fig:buffer}Role of the buffer in \CBROADCAST during link
      addition. $m''$ cannot precede $m'$. $p_2$'s deliveries remain hidden for
      the sake of clarity.}
  \end{center}
\end{figure}

% \begin{figure}
%   \begin{center}
%     \input{./input/figeq2buffer.tex}
%     \caption{\label{fig:eq2buffer}2-processes equivalent of
%       Figure~\ref{fig:buffer}.}
%   \end{center}
% \end{figure}

\paragraph{\emph{Example with buffer.}} The previous example does not depict the
buffer usage. The buffer becomes useful when a process broadcasts or forwards a
message between the opening of a link and the receipt of the corresponding
acknowledgment. Figure~\ref{fig:buffer} shows an example where a process uses a
buffer to ensure causal delivery of messages. Process $p_1$ connects to Process
$p_3$. Between the departure of the $locked$ message and the arrival of the
acknowledgment, $p_1$ broadcasts a message $m'$. Network conditions
delay the arrival of this message from $p_2$ to $p_3$ such that when Process
$p_1$ broadcasts another message $m''$, $m'$ is not yet arrived via
$p_2$. Fortunately, since $p_1$ buffered $m'$ and sent it after acknowledgment,
Process $p_3$ receives and delivers $m'$ before $m''$.


\begin{algorithm}
  \input{input/algoboundingbuffer.tex}
  \caption{\label{algo:boundingbuffer}Bounding the size of buffers and handling
    failures.}
\end{algorithm}

While Algorithm~\ref{algo:bufferbroadcast} ensures causal order of message
deliveries, buffers consume unbounded space. For instance, if the message
acknowledging the locked message fails to reach its destination, the
corresponding buffer continues to grow over broadcast and forwarded messages. 

Algorithm~\ref{algo:boundingbuffer} aims to bound the size of buffers and handle
network failures, i.e., crashed processes or lost messages. Now, our causal
broadcast can reset the buffer of a new link. Resets happen when either the
buffer size is above a threshold (see Line~\ref{line:maxsize}), or the
acknowledgment message took too long to come back (see
Line~\ref{line:timeout}). Each locked message has an identifier corresponding to
a link. When a process receives an acknowledgment, it knows if it expired due to
a timeout. We only keep the buffer corresponding to the latest locked
message. We bound the number of retries so the protocol does not stay stuck in a
loop of retries.

% \begin{algorithm}
%   \input{input/algosendfunctions.tex}
%   \caption{\label{algo:sendfunctions}Implementation of sending functions in
%     neighbor-to-neighbor peer-sampling protocols.}
% \end{algorithm}


\subsection{Proofs}

\begin{theorem}[FBC-broadcast in static networks is causal]
  \TODO{Meow}
\end{theorem}

\begin{theorem}[FBC-broadcast in dynamic networks subject to link removals is
  causal]
  As long as the network is not partitioned, FBC-broadcast remains causal when
  the number of links in the network is monotonically decreasing.
\end{theorem}

\begin{proof}
  \TODO{Redo.}  
  Removing a link does not change the delivery order of causally related
  messages. Proof of Theorem~\ref{theo:static} about causal order holds.
  However, removing a link may create network partitions. In such case, a
  message may not reach all processes. FBC-broadcast still ensures causal order,
  but uniform agreement is violated.
  % Consider Process $p$ belongs to partition $A$, Process $q$ belongs to
  % partition $B$. Messages broadcast by processes of Partition $A$ reach
  % processes of Partition $B$, but not the converse, assuming links are
  % unidirectional. Processes $p$ broadcasts a message $m$ received and delivered
  % by $q$. Then $q$ broadcasts a message $m'$
  % As long as the removal of links do not partition the network, messages reach
  % all processes. The proof is therefore identical to that of
  % Theorem~\ref{theo:static}.
\end{proof}

% \begin{theorem}[\label{theo:removals}FBC-broadcast in dynamic network subject to
%   link additions is not causal]
%   Using FBC-broadcast, adding links to the network may lead to causal order
%   violations.
% \end{theorem}

% \begin{figure}
%   \begin{center}
%     \input{./input/figproblem.tex}
%     \caption{\label{fig:problem}Adding a FIFO channel endangers causal
%       ordering.}
%   \end{center}
% \end{figure}

% \begin{figure}
%   \begin{center}
%     \input{./input/figeq2problem.tex}
%     \caption{\label{fig:eq2problem}2-processes equivalent problem of
%       Figure~\ref{fig:problem}.}
%   \end{center}
% \end{figure}

% \begin{proof}
%   Figure~\ref{fig:problem} illustrates the issue with the establishment of new
%   FIFO channels. In this example, a FIFO channel links $p_1$ to $p_2$; another
%   links $p_2$ to $p_3$; none links $p_1$ to $p_3$. Other FIFO channels may exist
%   but we do not show them for the sake of simplicity. Process $p_1$ broadcasts
%   $m$ and delivers it. $p_3$ receives it by the intermediary of $p_2$. In the
%   meantime, $p_1$ creates a FIFO channel to $p_3$, then broadcasts $m'$ to $p_2$
%   and $p_3$. Since the path through $p_2$ is longer in terms of propagation time
%   compared to the direct connections from $p_1$ to $p_3$, Process $p_3$ receives
%   and delivers $m'$ before $m$. It violates causal order, for $m'$ precedes $m$.
% \end{proof}





% This may create gaps in causal delivery, i.e., messages that should be delivered
% are still missing.  FIFO-based causal broadcast$^+$ aims to ensure that
% additional links never create gaps. The idea is to employ already working FIFO
% channels to know which messages arrived, at marginal cost. For instance,
% assuming that we have $d_p(m) \rightarrow d_p(m')$ and
% $d_p(m') \rightarrow d_p(m'')$, if Process $p$ knows that Process $q$ received
% and delivered at least $m$, it can send $m'$ then $m''$ to Process $q$. Any
% subsequent message from $p$ becomes safe to travel through the newly added link.

%%Knowing that at least Message $m$ arrived allows the process to send
%%depending messages $m'$, $m''$ 



% Algorithm~\ref{algo:bufferbroadcast} shows the instructions of our improved
% FIFO-based causal broadcast. Similarly to Algorithm~\ref{algo:fifobroadcast},
% each process has a set of neighbors to communicate with via FIFO
% channels. Messages transitively reach all processes using forwarding. Processes
% deliver and forward each message exactly once.  


%When Process $p$ gets notified that another FIFO channel to Process $q$ is
%available, it associates this channel with an empty buffer of messages.
% It also
%sends a \emph{locked} message to $q$. 

% Process $p$ does not use the new links until Process $q$ confirmed the receipt
% of the locked message. Acknowledgments do not have to travel through FIFO
% channels.  Once it receives the acknowledgment, $p$ empties the buffer of
% messages to $q$ and start using the channel normally.

\begin{theorem}[FBC-broadcast in dynamic network subject to link additions is
  causal]
  \TODO{Meow.}
\end{theorem}

\begin{proof}
  For static and dynamic networks with link removals, the proof is identical to
  those of Theorems~\ref{theo:static} and~\ref{theo:removals}, for the buffers
  do not activate in such instances. For dynamic networks with link additions,
  we must show that FBC-broadcast$^+$ ensures both
  FIFO order and local order. \\
  \textbf{FIFO:} Suppose a process $p$ broadcasts $m$ before $m'$. Consider that
  a correct process $q$ delivers $m'$. We must show that $q$ delivers $m$ before
  $m'$.  Since adding a FIFO link from a Process $r$ to any other Process $s$ is
  like adding potential FIFO paths from $p$ to $q$, we summarize this as a link
  from $p$ to $q$ with arbitrary settings but still FIFO.  \TODO{Should this be
    a proof?  Maybe a proof of equivalent model if kept}. \\   
  Since Process $q$ delivers $m'$ it either received $m'$ from already well
  established links, or from the new one. In the former case, the proof is
  identical to that of Theorem~\ref{theo:static}. In the latter case, Process
  $q$ delivers $m'$ means that process $p$ broadcasts $m$ then $m'$ either
  \begin{inparaenum}[(i)]
  \item \label{case:one} $m'$ during buffering and $m$ before buffering;
  \item \label{case:two} $m'$ during buffering and $m$ during buffering;
  \item \label{case:three} $m'$ after acknowledgment and $m$ before buffering;
  \item \label{case:four} $m'$ after acknowledgment and $m$ during buffering;
  \item \label{case:five} $m'$ after acknowledgment and $m$ after acknowledgment.
  \end{inparaenum}
  We must show that either 
  \begin{inparaenum}[(1)]
  \item \label{show:one} Process $q$ already received $m$ from another link
    before receiving $m'$ from the new link,
  \item \label{show:two} or that this new link conveyed $m$ before $m'$.
  \end{inparaenum}

  \begin{itemize}
  \item [(\ref{case:one})] Process $p$ put $m'$ in the buffer. Process $p$
    empties the buffer containing $m'$ after $p$ received an acknowledgment
    meaning that at least $m$ has been received at $q$. This
    shows~(\ref{show:one}).
  \item [(\ref{case:two})] Process $p$ put $m$ then $m'$ in the buffer. When the
    acknowledgment is received, it sends $m$ then $m'$ to Process $q$. This
    shows~(\ref{show:two}).
  \item [(\ref{case:three})] Identical to case~(\ref{case:one}) without the need
    of buffering.
  \item [(\ref{case:four})] Since Process $p$ empties the buffer containing $m$
    when it receives the acknowledgment, and since Process $p$ broadcasts $m'$
    afterwards using the new link, it shows~(\ref{show:two}).
  \item [(\ref{case:five})] It directly shows~(\ref{show:two}).
  \end{itemize}
  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  % If Process $p$ broadcasts $m$ before the link addition, Process $p$ either
  % broadcasts $m'$ during buffering phase or after acknowledgment: 
  % \begin{itemize}
  % \item In the former case, since the receipt of $m$ precedes the creation of the
  %   acknowledgement, when $p$ receives the acknowledgement, it empties the buffer
  %   containing $m'$ to $q$. Hence, from any path, Process $q$ receives and
  %   delivers $m$ before $m'$.
  % \item In the later case, the acknowledgement confirms that $q$ received
  %   $m$. Afterwards, when $p$ broadcasts $m'$ it travels, among others, the newly
  %   created link, and eventually arrives to $q$.
  % \end{itemize}
  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  % If Process $p$ broadcasts $m$ during buffering phase, Process $p$ either
  % broadcasts $m'$ during buffering phase or after acknowledgement.
  % \begin{itemize}
  % \item In the former case, $p$ puts $m$ in the buffer before $m'$. When $q$
  %   receives $m'$, either it already received $m$ from another FIFO channel or
  %   it already received $m$ from the emptied buffer that contained $m$ before
  %   $m'$.
  % \item In the later case, When $q$ receives $m'$, either it received $m$ from
  %   FIFO channel or the buffer that empties after acknowledgment.
  % \end{itemize}
  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  % If Process $p$ broadcasts $m$ after acknowledgement, Process $p$ broadcasts
  % $m'$ after acknowledgement. It corresponds to the static network (see proof of
  % Theorem~\ref{theo:static}).
  % In any case, process $q$ delivers $m$ before $m'$. \\
  \textbf{Local:} Since broadcast and forward have identical instructions, the
  proof is identical to that of FIFO order. \\
  % Suppose a process $p$ delivers $m$ before broadcasting $m'$. Consider a
  % correct process $q$ that delivers $m'$. We must show that $q$ delivers $m$
  % before $m'$. Just as the proof for Theorem~\ref{theo:static}, the difference
  % in our Algorithm compared to FIFO order demonstration is that Process $q$ may
  % have already received -- or is the origin of the broadcast of --
  % $m$. \TODO{Not over}  
  \textbf{Causal:} From Theorem~\ref{theo:causal}, since FBC-broadcast$^+$
  ensures both FIFO ordering and local ordering, it ensures causal ordering.
\end{proof}

\begin{theorem}[FBC-broadcast is causal in dynamic networks]
  \TODO{Miaw.}
\end{theorem}

\begin{proof}
  \TODO{Directly deduced from above theorems, meow.}
\end{proof}

\begin{theorem}[FBC-broadcast$^+$ is causal]
  As long as the network is not partitioned, FBC-broadcast$^+$ is causal in both
  static and dynamic networks.
\end{theorem}

\begin{proof}
  \TODO{Directly deduced from above theorems, meow.}
\end{proof}

\subsection{Complexity}
\label{subsec:complexity}

We review and discuss about the complexity of FBC-broadcast$^+$. We distinguish
the complexity led by causal ordering, the complexity led by reliable
broadcast, and the complexity led by the peer-sampling protocol.

\paragraph{Causal ordering.} Regarding traffic, the broadcast and forwarded
messages do not need to convey any control information. Regarding local space
consumption, our algorithm only requires to maintain buffers when a link is
being acknowledged. While Algorithm~\ref{algo:bufferbroadcast} shows no buffer
management which means that they can grow unbounded, we can easily bound
them. For instance, above a threshold we clear the buffer and send another
locked message, or we remove the link altogether.

\paragraph{Reliable broadcast.} Algorithm~\ref{algo:reliablebroadcast} shows the
instructions of reliable broadcast. Even in presence of message duplicates it
avoids multiple deliveries of a same message. To achieve this, the most
straightforward structure is a set saving all new received messages. However, it
increases linearly with the number of delivered messages (\REF). Assigning a
unique identifier $\langle p,\, counter \rangle$ to each message changes the
complexity. It becomes a vector that increases linearly with the number of
processes that ever broadcast a message~\cite{fidge1988timestamps}. Using
interval tree clocks~\cite{almeida2008interval} slightly overloads messages with
identifiers but it improves the space complexity: the local structure increases
linearly with the number of processes that are currently involved in
broadcasting.


% \TODO{Rework.} Represented in Algorithms~\ref{algo:fifobroadcast}
% and~\ref{algo:bufferbroadcast} by Function $alreadyReceived$. Causal ordering
% and detecting duplicated receipts are orthogonal problems. In this paper, we do
% not provide an implementation for the later. The simplest approach consists in
% saving all received messages (\REF). However, the size of this set linearly and
% monotonically increases as the number of broadcast messages increases. One would
% prefer an approach based on vectors where one entry corresponds to the number of
% messages received by a particular process~\cite{fidge1988timestamps}. Such
% approach do not require to piggyback additional data in the message. However, it
% requires to store locally a vector the size of which increases linearly compared
% to the number of processes that ever broadcast a message. Interval tree
% clocks~\cite{almeida2008interval} allow processes to reduce this complexity. It
% becomes linear in terms of number of processes that are currently involved in
% broadcasting. Possible improvements could take advantage of the fact that the
% number of duplicates is equal to the number of incoming links. However, it does
% not hold in dynamic networks where additional links are established. Finding a
% sublinear bound for detecting duplicated receipts remains an open problem.


\paragraph{Peer-sampling protocol.} The number of messages sent by each process,
the number of hops for a message to reach all processes, \TODO{etc.} are
interdependent values set by the peer-sampling protocol. For instance, random
peer-sampling protocols~\cite{jelasity2007gossip} provide each process with a
random subset of neighbors the size of which is considerably smaller than the
network size. Since the neighborhood size is logarithmic compared to the network
size, the number of messages sent by each process for each broadcast is
logarithmic. Since it builds a topology close to random graphs, messages take a
logarithmic number of hops to reach all processes, \TODO{etc.}  In addition,
random peer-sampling protocols such as \SPRAY~\cite{nedelec2017adaptive} or
\CYCLON~\cite{voulgaris2005cyclon} build neighborhoods using only
neighbor-to-neighbor interactions, i.e., they establish links only two hops
apart. Thus, it becomes easy to design a 4-hops $sendLocked$-$sendAck$
function. Under such settings, we can assume that buffers that grow between the
departure of a locked message and the arrival of the corresponding
acknowledgment remain small in size, even without threshold policies.

The next section reviews state-of-the-art techniques designed to maintain causal
order among messages.

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../paper"
%%% End:
