
\section{Causal broadcast}
\label{sec:proposal}

In this section, we show that reliable broadcast becomes causal as soon as links
ensure FIFO order (e.g. TCP). Consequently, it ensures causal delivery of
messages for free. It checks for duplicate messages the cost of which remains
confined to a local scope. Contrarily to
state-of-the-art~\cite{almeida2008interval,birman1987reliable,fidge1988timestamps,mattern1989virtual,hadzilacos1993fault,mostefaoui2017probabilistic,singhal1992efficient},
it does not overload messages with control information.  However, we show that
causal order may be violated in dynamic networks. We propose a causal broadcast
that works in such settings. The intuition is that causally related messages are
never missing, for all paths --- including new --- from the broadcaster to every
peers convey all messages in the appropriate order.  It still does not overload
messages and the local space requirements remain small. Using this broadcast,
large and dynamic systems can finally afford causal broadcast.

% We propose an approach guaranteeing causal order to uniform reliable
% broadcasts. It only makes use of FIFO communication channels (e.g. TCP), and
% relies on scalable peer-sampling protocols that must not create network
% partitions (e.g. \SPRAY~\cite{nedelec2017adaptive}, or
% \CYCLON~\cite{voulgaris2005cyclon}).

% \TODO{If ok with model section, change this paragraph a bit.}
% Section~\ref{subsec:fifobroadcast} starts by showing that FIFO-based broadcast
% is sufficient to provide causal delivery of messages. This result holds if the
% network is static or links are removed only. It does not hold if links are added
% to the network. Section~\ref{subsec:bufferbroadcast} provides a simple algorithm
% that solves this issue. It allows processes to use a causal broadcast which
% alleviates applications of the burden of tracking causal relationships.

\subsection{2-processes equivalent model}

\begin{figure}
  \begin{center}
    \input{./input/fig2eqmodel.tex}
    \caption{\label{fig:2eqmodel}2-processes equivalent of a broadcast from any
      process to any other.}
    \end{center}
\end{figure}

\TODO{Maybe not here or maybe remove.}

When a process broadcasts a message, processes receiving it forward it exactly
once. Messages may be received multiple times by a process depending on the
peer-sampling protocol. They receive as many duplicated messages as they have
incoming links.  Considering only the process that sent the message that led to
a forwarding as parent, we can build a directed acyclic graph using the paths
taken by messages from the origin of the broadcast to any process.

Figure~\ref{fig:2eqmodel} shows the equivalent model with 2 processes. Channels
of arbitrary speed convey messages from Process $p_{from}$ to Process
$p_{to}$. When Process $p_{to}$ sends a message, it sends it through all
links. Even though they have different speeds that may change at arbitrary time,
if channels are FIFO, Process $p_{to}$ will receive messages in the same order as
Process $p_{from}$ sent them.


\subsection{FIFO-based causal broadcast}
\label{subsec:fifobroadcast}

Algorithm~\ref{algo:reliablebroadcast} shows the instructions of a uniform
reliable broadcast. It relies on a peer-sampling protocol that provides links to
communicate with other processes. When these links are FIFO, the broadcast
becomes causal under certain conditions.

% The FIFO-based causal broadcast relies on a peer-sampling protocol. It provides
% a set of neighbors to communicate with via FIFO channels. The peer-sampling
% protocol must ensure that the network is not partitioned.

\begin{definition}[FIFO communication channel]
  If Process $p$ sends a message $m$ then $m'$ to Process $q$ using a FIFO
  channel, $q$ receives $m$ before $m'$.
\end{definition}

% \TODO{Rework this part, rework next algo as well.}

% Algorithm~\ref{algo:fifobroadcast} shows the instructions of the causal
% broadcast mechanism built using FIFO channels. Functions $\textsc{broadcast}$
% and $\textsc{forward}$ are distinct although holding the same instructions to
% highlight that only 1 process broadcasts while all other processes
% forward. Function $\textsc{receive}$ makes sure that each process forwards each
% message exactly once. Function $\textsc{alreadyReceived}$ checks if a message
% has already been received by the process. We voluntarily keep the implementation
% out of this paper, for it constitutes an orthogonal problem. It is worth noting
% that this feature is achievable without overhead in terms of message size.

\begin{definition}[Static network]
  A network is static if it comprises an immutable set of edges and an immutable
  set of processes.
\end{definition}

% \paragraph{Static networks.} A network is a set of processes linked by a set
% of channels. In a static network, processes cannot fail nor leave, and links
% cannot be created nor removed. In this context, FIFO channels are sufficient
% to provide causal ordering of messages.

\begin{theorem}[\label{theo:static}FBC-broadcast in static networks is causal]
  Assuming a static network without partitions, FBC-broadcast is causal.
\end{theorem}

\begin{proof}
  To prove that FBC-broadcast is causal, we must show that it ensures validity,
  uniform agreement, uniform integrity, and causal order -- that is FIFO order
  and Local order. \\
  \textbf{Validity, uniform agreement, uniform integrity:} FBC-broadcast is an
  R-broadcast. \\
  % \textbf{\TODO{Validity:}} A delivery instruction always follows a broadcast
  % instruction.\\
  % \textbf{\TODO{Uniform agreement:}} All processes broadcast or forward messages
  % before delivery. \TODO{Add eventual receipt. There exist a path from any --
  %   correct or not -- process to any other correct process.} \\
  % \textbf{\TODO{Uniform integrity:}} $alreadyReceived$ makes sure that at most
  % one message is delivered, even if duplicated. Before entering in receipt
  % instructions, the message must be broadcast. \\
  \textbf{FIFO:} Suppose a process $p$ broadcasts $m$ before $m'$. Consider that
  a correct process $q$ delivers $m'$. We must show that $q$ delivers $m$ before
  $m'$. \\
  Since the peer-sampling protocol ensures that the network is not partitioned,
  since each process receiving a message forwards it exactly once to all its
  neighborhood, each message eventually reaches all processes and each link
  conveys all messages exactly once. \\
  Since each process forwards each message in a FIFO manner, since messages
  travel using FIFO channels, and since each channel conveys all messages
  exactly once, they convey the messages in the order they were broadcast. \\
  Since Process $p$ broadcasts $m$ before $m'$, and since Process $q$ delivers
  $m'$, Process $q$ received $m$ before $m'$. \\
  Since processes deliver messages in the order they received them, Process $q$
  delivered $m$ before $m'$. \\
  % Process $p$ broadcast message $m$ before broadcasting $m'$ to all its
  % neighborhood using FIFO channels. Each neighbor eventually receives and
  % delivers $m$ then $m'$. Each neighbor forwards each message exactly once in
  % the order they delivered (\TODO{received?}) them to all its neighbors using
  % FIFO channels. Since we assume a network without clusters, messages eventually
  % reach all processes. Process $q$ eventually receives and delivers $m$ first,
  % then it eventually receives
  % and delivers $m'$. \\
  \textbf{Local:} Suppose a process $p$ delivers $m$ before broadcasting
  $m'$. Consider a correct process $q$ that delivers $m'$. We must show that $q$
  delivers $m$ before $m'$. \\
  Since broadcast and forward have identical instructions, we add to ``processes
  receive the messages in the order they were broadcast'' the statement ``if a
  process forwards a message before broadcasting one, processes will receive the
  forwarded message before the broadcast one'' and converse. \\
  Since Process $q$ delivers $m'$, channels from which it receives $m'$ already
  conveyed $m$. Since processes deliver messages in the order they received
  them, Process $q$ delivers $m$ before $m'$. \\
  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  % Either Process $q$ received $m$ before Process $p$ or not.
  % In the later case, since broadcast and forward have identical instructions,
  % the proof is identical to FIFO's one. In the former case,
  % \begin{inparaenum}[(i)]
  % \item since processes deliver messages in the order they receive them, and
  % \item since Process $q$ already received or broadcast $m$ when Process $p$
  %   broadcasts $m'$, and
  % \item since we assume a network without partitions, Process $q$ eventually
  %   receives, hence delivers, $m'$ afterwards.
  % \end{inparaenum}
  %% In any case, Process $q$ delivers $m$ before $m'$. \\
  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  % Since $p$ delivers $m$ before broadcasting $m'$, it forwards $m$ to all its
  % neighbors before broadcasting $m'$ to the same neighbors. Similarly to FIFO
  % ordering, due to the use of FIFO channels, the forwardings, and the absence of
  % network clusters, Process $q$ already received or eventually receives $m$ when
  % it receives $m'$. Thus, it delivers $m$ before
  % delivering $m'$. \\
  \textbf{Causal:} From Theorem~\ref{theo:causal}, since FBC-broadcast ensures
  both FIFO ordering and Local ordering, it ensures Causal ordering.
\end{proof}


\begin{figure}
  \begin{center}
    \input{./input/figstatic.tex}
    \caption{\label{fig:static}FIFO channels are sufficient to provide causal
      order in static networks.}
  \end{center}
\end{figure}

\paragraph{\emph{Example.}} Figure~\ref{fig:static} shows FBC-broadcast solves
the causal order violation from Figure~\ref{fig:generalproblem} by using FIFO
channels.  The figure shows a static network comprising 3 processes $p_1$,
$p_2$, and $p_3$ linked to each other. The figure does not show messages sent by
$p_3$ for the sake of clarity.  The processes receive $m$ and $m'$ multiple
times but there exists no link in the paths from $p_2$ to $p_3$ that carries $m'$
without having carried $m$ beforehand. Hence, the delivery of $m$ always
precedes the delivery of $m'$ at any process.

% \paragraph{Dynamic networks.} Removing a channel does not impair causal
% ordering of messages except if it generates network
% partitions. \TODO{Theorem.}

\begin{definition}[Dynamic network]
  A network is dynamic if it comprises a mutable set of edges and a mutable set
  of processes.
\end{definition}

\begin{theorem}[FBC-broadcast in dynamic networks subject to link removals is
  causal]
  As long as the network is not partitioned, FBC-broadcast remains causal when
  the number of links in the network is monotonically decreasing.

%%  \TODO{In fact, it
%%    remains causal even when partitionned. But uniform agreement is violated.}
\end{theorem}

\begin{proof}
  Removing a link does not change the delivery order of causally related
  messages. Proof of Theorem~\ref{theo:static} about causal order holds.
  However, removing a link may create network partitions. In such case, a
  message may not reach all processes. FBC-broadcast still ensures causal order,
  but uniform agreement is violated.
  % Consider Process $p$ belongs to partition $A$, Process $q$ belongs to
  % partition $B$. Messages broadcast by processes of Partition $A$ reach
  % processes of Partition $B$, but not the converse, assuming links are
  % unidirectional. Processes $p$ broadcasts a message $m$ received and delivered
  % by $q$. Then $q$ broadcasts a message $m'$
  % As long as the removal of links do not partition the network, messages reach
  % all processes. The proof is therefore identical to that of
  % Theorem~\ref{theo:static}.
\end{proof}

\begin{theorem}[\label{theo:removals}FBC-broadcast in dynamic network subject to
  link additions is not causal]
  Using FBC-broadcast, adding links to the network may lead to causal order
  violations.
\end{theorem}

\begin{figure}
  \begin{center}
    \input{./input/figproblem.tex}
    \caption{\label{fig:problem}Adding a FIFO channel endangers causal
      ordering.}
  \end{center}
\end{figure}

\begin{figure}
  \begin{center}
    \input{./input/figeq2problem.tex}
    \caption{\label{fig:eq2problem}2-processes equivalent problem of
      Figure~\ref{fig:problem}.}
  \end{center}
\end{figure}

\begin{proof}
  Figure~\ref{fig:problem} illustrates the issue with the establishment of new
  FIFO channels. In this example, a FIFO channel links $p_1$ to $p_2$; another
  links $p_2$ to $p_3$; none links $p_1$ to $p_3$. Other FIFO channels may exist
  but we do not show them for the sake of simplicity. Process $p_1$ broadcasts
  $m$ and delivers it. $p_3$ receives it by the intermediary of $p_2$. In the
  meantime, $p_1$ creates a FIFO channel to $p_3$, then broadcasts $m'$ to $p_2$
  and $p_3$. Since the path through $p_2$ is longer in terms of propagation time
  compared to the direct connections from $p_1$ to $p_3$, Process $p_3$ receives
  and delivers $m'$ before $m$. It violates causal order, for $m'$ precedes $m$.
\end{proof}

Handling dynamic networks is mandatory for causal broadcast
mechanisms. Unfortunately, FBC-broadcast fails when links are added to the
network. Staying with the principle of FIFO-based broadcast, we extend
FBC-broadcast to fully handle dynamic networks. The solution is lightweight and
only uses local knowledge.

\subsection{FIFO-based causal broadcast+}
\label{subsec:bufferbroadcast}

The issue is that new links may act as shortcut for messages. First messages
that travel through new links may arrive before preceding messages that took
longer paths. New links create additional diffusion paths that potentially
disorder messages. To solve this issue, we make sure that even new links convey
all messages in the right order. The idea is to use already established FIFO
links to acknowledge the receipt of messages at a marginal cost. The process
knows the potentially missing messages. It sends them in the right order using
the new FIFO link, then it starts using it normally. Consequently, new links
do not create diffusion paths breaking causal order.

% This may create gaps in causal delivery, i.e., messages that should be delivered
% are still missing.  FIFO-based causal broadcast$^+$ aims to ensure that
% additional links never create gaps. The idea is to employ already working FIFO
% channels to know which messages arrived, at marginal cost. For instance,
% assuming that we have $d_p(m) \rightarrow d_p(m')$ and
% $d_p(m') \rightarrow d_p(m'')$, if Process $p$ knows that Process $q$ received
% and delivered at least $m$, it can send $m'$ then $m''$ to Process $q$. Any
% subsequent message from $p$ becomes safe to travel through the newly added link.

%%Knowing that at least Message $m$ arrived allows the process to send
%%depending messages $m'$, $m''$ 


Algorithm~\ref{algo:bufferbroadcast} shows the instructions of our improved
causal broadcast. It solves the dynamic network issues in 3 steps.  Compared to
Algorithm~\ref{algo:reliablebroadcast}, it adds a structure associating each
opening channel with a buffer of messages.  When a process $p$ wants to use a
link to a process $q$ for causal broadcast,
\begin{enumerate}[(i)]
\item it must use the FIFO channels already in use to transmit a message to $q$
  and wait for its acknowledgment (see Line~\ref{line:sendlocked}). We leave
  aside the implementation of this send function (e.g. broadcast or
  routing). However, using already established FIFO links constitutes a cheap
  way to achieve it.
\item While awaiting for this acknowledgment, $p$ must buffer each message it
  broadcasts or forwards (see
  Line~\ref{line:bufferbroadcast},~\ref{line:bufferforward}). When $q$ receives
  $p$'s message, it acknowledges it (see Line~\ref{line:sendack}). The message it sends can travel through any
  communication mean.
\item When $p$ receives the acknowledgment from $q$, it uses the FIFO channel
  from $p$ to $q$ to send its buffered messages (see
  Line~\ref{line:emptybuffer}). Afterwards, $p$ uses the new channel normally.
\end{enumerate}

\begin{algorithm}[h]
  \input{./input/algobufferbroadcast.tex}
  \caption{\label{algo:bufferbroadcast}FBC-broadcast$^+$ at Process $p$.}
\end{algorithm}


% Algorithm~\ref{algo:bufferbroadcast} shows the instructions of our improved
% FIFO-based causal broadcast. Similarly to Algorithm~\ref{algo:fifobroadcast},
% each process has a set of neighbors to communicate with via FIFO
% channels. Messages transitively reach all processes using forwarding. Processes
% deliver and forward each message exactly once.  


%When Process $p$ gets notified that another FIFO channel to Process $q$ is
%available, it associates this channel with an empty buffer of messages.
% It also
%sends a \emph{locked} message to $q$. 

% Process $p$ does not use the new links until Process $q$ confirmed the receipt
% of the locked message. Acknowledgments do not have to travel through FIFO
% channels.  Once it receives the acknowledgment, $p$ empties the buffer of
% messages to $q$ and start using the channel normally.

\begin{theorem}[FBC-broadcast$^+$ is causal]
  As long as the network is not partitioned, FBC-broadcast$^+$ is causal in both
  static and dynamic networks.
\end{theorem}

\begin{proof}
  For static and dynamic networks with link removals, the proof is identical to
  those of Theorems~\ref{theo:static} and~\ref{theo:removals}, for the buffers
  do not activate in such instances. For dynamic networks with link additions,
  we must show that FBC-broadcast$^+$ ensures both
  FIFO order and Local order. \\
  \textbf{FIFO:} Suppose a process $p$ broadcasts $m$ before $m'$. Consider that
  a correct process $q$ delivers $m'$. We must show that $q$ delivers $m$ before
  $m'$.  Since adding a FIFO link from a Process $r$ to any other Process $s$ is
  like adding potential FIFO paths from $p$ to $q$, we summarize this as a link
  from $p$ to $q$ with arbitrary settings but still FIFO.  \TODO{Should this be
    a proof?  Maybe a proof of equivalent model if kept}. \\   
  Since Process $q$ delivers $m'$ it either received $m'$ from already well
  established channels, or from the new one. In the former case, the proof is
  identical to that of Theorem~\ref{theo:static}. In the latter case, Process
  $q$ delivers $m'$ means that process $p$ broadcasts $m$ then $m'$ either
  \begin{inparaenum}[(i)]
  \item \label{case:one} $m'$ during buffering and $m$ before buffering;
  \item \label{case:two} $m'$ during buffering and $m$ during buffering;
  \item \label{case:three} $m'$ after acknowledgment and $m$ before buffering;
  \item \label{case:four} $m'$ after acknowledgment and $m$ during buffering;
  \item \label{case:five} $m'$ after acknowledgment and $m$ after acknowledgment.
  \end{inparaenum}
  We must show that either 
  \begin{inparaenum}[(1)]
  \item \label{show:one} Process $q$ already received $m$ from another channel
    before receiving $m'$ from the new channel,
  \item \label{show:two} or that this new channel conveyed $m$ before $m'$.
  \end{inparaenum}

  \begin{itemize}
  \item [(\ref{case:one})] Process $p$ put $m'$ in the buffer. Process $p$
    empties the buffer containing $m'$ after $p$ received an acknowledgment
    meaning that at least $m$ has been received at $q$. This
    shows~(\ref{show:one}).
  \item [(\ref{case:two})] Process $p$ put $m$ then $m'$ in the buffer. When the
    acknowledgment is received, it sends $m$ then $m'$ to Process $q$. This
    shows~(\ref{show:two}).
  \item [(\ref{case:three})] Identical to case~(\ref{case:one}) without the need
    of buffering.
  \item [(\ref{case:four})] Since Process $p$ empties the buffer containing $m$
    when it receives the acknowledgment, and since Process $p$ broadcasts $m'$
    afterwards using the new channel, it shows~(\ref{show:two}).
  \item [(\ref{case:five})] It directly shows~(\ref{show:two}).
  \end{itemize}
  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  % If Process $p$ broadcasts $m$ before the link addition, Process $p$ either
  % broadcasts $m'$ during buffering phase or after acknowledgment: 
  % \begin{itemize}
  % \item In the former case, since the receipt of $m$ precedes the creation of the
  %   acknowledgement, when $p$ receives the acknowledgement, it empties the buffer
  %   containing $m'$ to $q$. Hence, from any path, Process $q$ receives and
  %   delivers $m$ before $m'$.
  % \item In the later case, the acknowledgement confirms that $q$ received
  %   $m$. Afterwards, when $p$ broadcasts $m'$ it travels, among others, the newly
  %   created link, and eventually arrives to $q$.
  % \end{itemize}
  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  % If Process $p$ broadcasts $m$ during buffering phase, Process $p$ either
  % broadcasts $m'$ during buffering phase or after acknowledgement.
  % \begin{itemize}
  % \item In the former case, $p$ puts $m$ in the buffer before $m'$. When $q$
  %   receives $m'$, either it already received $m$ from another FIFO channel or
  %   it already received $m$ from the emptied buffer that contained $m$ before
  %   $m'$.
  % \item In the later case, When $q$ receives $m'$, either it received $m$ from
  %   FIFO channel or the buffer that empties after acknowledgment.
  % \end{itemize}
  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  % If Process $p$ broadcasts $m$ after acknowledgement, Process $p$ broadcasts
  % $m'$ after acknowledgement. It corresponds to the static network (see proof of
  % Theorem~\ref{theo:static}).
  % In any case, process $q$ delivers $m$ before $m'$. \\
  \textbf{Local:} Since broadcast and forward have identical instructions, the
  proof is identical to that of FIFO order. \\
  % Suppose a process $p$ delivers $m$ before broadcasting $m'$. Consider a
  % correct process $q$ that delivers $m'$. We must show that $q$ delivers $m$
  % before $m'$. Just as the proof for Theorem~\ref{theo:static}, the difference
  % in our Algorithm compared to FIFO order demonstration is that Process $q$ may
  % have already received -- or is the origin of the broadcast of --
  % $m$. \TODO{Not over}  
  \textbf{Causal:} From Theorem~\ref{theo:causal}, since FBC-broadcast$^+$
  ensures both FIFO ordering and Local ordering, it ensures Causal ordering.
\end{proof}

\begin{figure}
  \begin{center}
    \input{./input/figsolved.tex}
    \caption{\label{fig:solved}FBC-broadcast$^+$ in dynamic networks. $m'$
      cannot precede $m$. $p_2$'s deliveries remain hidden for the sake of
      clarity.}
  \end{center}
\end{figure}

\begin{figure}
  \begin{center}
    \input{./input/figeq2solved.tex}
    \caption{\label{fig:eq2solved}2-processes equivalent of Figure~\ref{fig:solved}.}
  \end{center}
\end{figure}

\paragraph{\emph{Example without buffer.}} Figure~\ref{fig:solved} shows how our
algorithm solves causal order violations. Similarly to Figure~\ref{fig:problem},
a FIFO channel links $p_1$ to $p_2$; another link $p_2$ to $p_3$; none links
$p_1$ to $p_3$. Process $p_1$ broadcasts $m$. Then $p_1$ wishes to create a link
to $p_3$. It sends a message to $p_3$ using its FIFO channels. Thus, $m$
precedes this message at $p_3$. When $p_3$ acknowledges this message to $p_1$
using any communication way, the later knows that it $p_3$ received and
delivered at least $m$. Hence, all subsequent broadcast from $p_1$ can use the
new communication channel safely. When $p_1$ broadcasts $m'$, there exist no
path where $m'$ arrives before $m$.

\begin{figure}
  \begin{center}
    \input{./input/figbuffer.tex}
    \caption{\label{fig:buffer}Role of the buffer in FBC-broadcast$^+$ during
      link addition. $m''$ cannot precede $m'$. $p_2$'s deliveries remain hidden
      for the sake of clarity.}
  \end{center}
\end{figure}

\begin{figure}
  \begin{center}
    \input{./input/figeq2buffer.tex}
    \caption{\label{fig:eq2buffer}2-processes equivalent of
      Figure~\ref{fig:buffer}.}
  \end{center}
\end{figure}

\paragraph{\emph{Example with buffer.}} The previous example does not depict the
buffer usage. The buffer becomes useful when a process broadcasts or forwards a
message between the opening of a channel and the receipt of the corresponding
acknowledgment. Figure~\ref{fig:buffer} shows an example where a process uses a
buffer to ensure causal delivery of messages. Process $p_1$ connects to Process
$p_3$. Between the departure of the $locked$ message and the arrival of the
acknowledgement, $p_1$ broadcasts a message $m'$. Network conditions
delay the arrival of this message from $p_2$ to $p_3$ such that when Process
$p_1$ broadcasts another message $m''$, $m'$ is not yet arrived via
$p_2$. Fortunately, since $p_1$ buffered $m'$ and sent it after acknowledgment,
Process $p_3$ receives and delivers $m'$ before $m''$.


\subsection{Complexity}
\label{subsec:complexity}

We review and discuss about the complexity of FBC-broadcast$^+$. We distinguish
the complexity led by causal ordering, the complexity led by reliable
broadcast, and the complexity led by the peer-sampling protocol.

\paragraph{Causal ordering.} Regarding traffic, the broadcast and forwarded
messages do not need to convey any control information. Regarding local space
consumption, our algorithm only requires to maintain buffers when a link is
being acknowledged. While Algorithm~\ref{algo:bufferbroadcast} shows no buffer
management which means that they can grow unbounded, we can easily bound
them. For instance, above a threshold we clear the buffer and send another
locked message, or we remove the link altogether.

\paragraph{Reliable broadcast.} Algorithm~\ref{algo:reliablebroadcast} shows the
instructions of reliable broadcast. Even in presence of message duplicates it
avoids multiple deliveries of a same message. To achieve this, the most
straightforward structure is a set saving all new received messages. However, it
increases linearly with the number of delivered messages (\REF). Assigning a
unique identifier $\langle p,\, counter \rangle$ to each message changes the
complexity. It becomes a vector that increases linearly with the number of
processes that ever broadcast a message~\cite{fidge1988timestamps}. Using
interval tree clocks~\cite{almeida2008interval} slightly overloads messages with
identifiers but it improves the space complexity: the local structure increases
linearly with the number of processes that are currently involved in
broadcasting.


% \TODO{Rework.} Represented in Algorithms~\ref{algo:fifobroadcast}
% and~\ref{algo:bufferbroadcast} by Function $alreadyReceived$. Causal ordering
% and detecting duplicated receipts are orthogonal problems. In this paper, we do
% not provide an implementation for the later. The simplest approach consists in
% saving all received messages (\REF). However, the size of this set linearly and
% monotonically increases as the number of broadcast messages increases. One would
% prefer an approach based on vectors where one entry corresponds to the number of
% messages received by a particular process~\cite{fidge1988timestamps}. Such
% approach do not require to piggyback additional data in the message. However, it
% requires to store locally a vector the size of which increases linearly compared
% to the number of processes that ever broadcast a message. Interval tree
% clocks~\cite{almeida2008interval} allow processes to reduce this complexity. It
% becomes linear in terms of number of processes that are currently involved in
% broadcasting. Possible improvements could take advantage of the fact that the
% number of duplicates is equal to the number of incoming links. However, it does
% not hold in dynamic networks where additional links are established. Finding a
% sublinear bound for detecting duplicated receipts remains an open problem.


\paragraph{Peer-sampling protocol.} The number of messages sent by each process,
the number of hops for a message to reach all processes, \TODO{etc.} are
interdependent values set by the peer-sampling protocol. For instance, random
peer-sampling protocols~\cite{jelasity2007gossip} provide each process with a
random subset of neighbors the size of which is considerably smaller than the
network size. Since the neighborhood size is logarithmic compared to the network
size, the number of messages sent by each process for each broadcast is
logarithmic. Since it builds a topology close to random graphs, messages take a
logarithmic number of hops to reach all processes, \TODO{etc.}  In addition,
random peer-sampling protocols such as \SPRAY~\cite{nedelec2017adaptive} or
\CYCLON~\cite{voulgaris2005cyclon} build neighborhoods using only
neighbor-to-neighbor interactions, i.e., they establish links only two hops
apart. Thus, it becomes easy to design a 4-hops $sendLocked$-$sendAck$
function. Under such settings, we can assume that buffers that grow between the
departure of a locked message and the arrival of the corresponding
acknowledgment remain small in size, even without threshold policies.

The next section reviews state-of-the-art techniques designed to maintain causal
order among messages.

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../paper"
%%% End:
