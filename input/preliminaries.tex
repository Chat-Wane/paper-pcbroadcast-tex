
\section{Preliminaries}
\label{sec:preliminaries}

Definitions and theorems come from~\cite{hadzilacos1994modular}.

\begin{definition}[Network]
  A network $N$ comprises a set of processes $P$. Each Process runs a set of
  instructions sequentially. \\
  A network $N$ also comprises a set of links $E: P \times P$. $p$'s
  neighborhood $Q$ is the set of links departing from $p$. Processes can
  communicate with their 
  neighbors using messages. \\
  Processes are faulty if they crash, otherwise they are correct. The set of
  correct processes is $C$. There are no byzantine processes.
\end{definition}

\begin{definition}[Static and dynamic networks]
  A network is static if both its set of processes and its set of edges are
  immutable. Otherwise, the network is dynamic.
\end{definition}

For the rest of the paper, we only consider networks without partitions.

\begin{definition}[Network partition]
  A network has partitions if there exist two correct processes without any path
  between them, i.e., without a link or a sequence of links comprising correct
  processes only.
\end{definition}

%\TODO{Replace ``network'' by  ``distributed system'' ?}

We define time in a logical sense using Lamport's
definition~\cite{lamport1978time}.

\begin{definition}[Happen before]
  Happen before is a transitive, irreflexive, and antisymmetric relation that
  defines a strict partial orders of events. At process $p$, Event $e$ happens
  before -- or precedes -- Event $e'$ is noted $e_p \rightarrow e'_p$. The
  sending of a message $s_p(m)$ always precedes its receipt $r_q(m)$: \\
  $\forall p,\,q \in P, s_p(m) \rightarrow r_q(m)$.
\end{definition}

Processes communicate by sending messages to other processes. They can send
messages to specific processes or all of them.

\begin{definition}[Uniform reliable broadcast]
  A process $p$ can broadcast a message $b_p(m)$, receive a message $r_p(m)$,
  and deliver a message $d_p(m)$.  When a process $p$ broadcasts a message $m$
  to all processes of the network, correct processes eventually receive it: 
  $\forall p \in P,\, (b_p(m) \Leftrightarrow \forall q \in P,\, r_q(m))$. \\
  Uniform reliable broadcast guarantees 3 properties: \\
  \textbf{Validity:} If a correct process broadcasts a message, then it
  eventually
  delivers it: $\forall p \in C,\, b_p(m) \rightarrow d_p(m)$. \\
  \textbf{Uniform Agreement:} If a process -- correct or not -- delivers a
  message,
  then all correct processes eventually deliver it:\\
  $\forall p \in P,\, (d_p(m) \implies \forall q \in C,\, d_q(m))$. \\
  \textbf{Uniform Integrity:} A process delivers a message at most once, and
  only if it was previously broadcast:\\
  $\forall p \in P,\, \neg(d_p(m) \rightarrow d_p(m)) \wedge$\\$d_p(m) \implies
  \exists q \in P,\, b_q(m) \rightarrow d_p(m)$.
\end{definition}

\begin{algorithm}[h]
  \input{./input/algoreliablebroadcast.tex}
  \caption{\label{algo:reliablebroadcast}R-broadcast at Process $p$.}
\end{algorithm}

Algorithm~\ref{algo:reliablebroadcast} shows the instructions of a uniform
reliable broadcast. It uses a structure that keeps track of received messages in
order to deliver them at most once. 
%It uses a peer-sampling protocol that
%provides neighbors to communicate with, i.e., a set of links. 
%%Assuming a network without partitions meaning that there exists at least one
%path from any process to any correct process, then all correct processes
%eventually receive all messages at least once:
Since the network does not have partitions, processes either receive the message
directly from the broadcaster or transitively. Thus, all correct processes
eventually deliver all messages exactly once. This algorithm ensures validity,
uniform agreement, and uniform integrity.

In addition to reliably conveying messages to all correct processes, broadcast
protocols can ensure that messages are delivered in a specific order.

To order messages broadcast from one process, we define FIFO order.

\begin{definition}[FIFO order]
  If a process broadcasts two messages, processes deliver the first before the
  second:\\
  $\forall p,\,q \in P,\,$\\$b_p(m) \rightarrow b_p(m') \implies d_q(m) \rightarrow
  d_q(m')$.
\end{definition}

To order messages broadcast by different processes, we define local order.

\begin{definition}[Local order]
  If a process broadcasts a message after having delivered another message
  broadcast by another process, processes deliver the later before the former:\\
  $\forall p,\,q,\,r,\, \in P,\,p\neq q,\,$\\$b_p(m) \wedge d_q(m) \rightarrow b_q(m') \implies d_r(m) \rightarrow d_r(m')$.
\end{definition}

To order messages broadcast by every processes, we define causal order.

\begin{definition}[Causal order]
  The delivery order of messages follows the happen before relationships of the
  corresponding broadcasts:\\ $\forall
  p,\,q,\,r \in P,\,$\\$b_p(m) \rightarrow b_q(m') \implies d_r(m) \rightarrow d_r(m')$.
\end{definition}

\begin{theorem}[\label{theo:causal}Causal order equivalence]
%  The intersection of 
  FIFO order and local order is equivalent to causal order.
\end{theorem}

\begin{definition}[Causal broadcast]
  Causal broadcast is a uniform reliable broadcast ensuring causal order.
\end{definition}

\begin{figure}
  \begin{center}
  \input{./input/figgeneralproblem.tex}
  \caption{\label{fig:generalproblem}Broadcast without causal order
    enforcement.}
  \end{center}
\end{figure}

\EXAMPLE{Example of causal order violation.}{Figure~\ref{fig:generalproblem}
  illustrates the need of an additional mechanism ensuring causal order. Process
  $p_1$ broadcasts and delivers $m$. Process $p_2$ receives and delivers
  $m$. Then, it broadcasts and delivers $m'$. Process $p_3$ receives $m'$ before
  $m$. Without any causal order enforcement, $p_3$ delivers $m'$ before $m$
  violating the condition stating that the delivery of $m$ should precede the
  delivery of $m'$.  }

Multiple approaches achieve causal delivery by piggybacking control information
in broadcast messages (\REF). Upon receipt of messages, processes check if the
message is ready to be delivered or must be delayed until preceding messages 
arrive.

\begin{figure}
  \begin{center}
    \input{input/figvector.tex}
    \caption{\label{fig:vector}Causal broadcast using vector clocks.}
  \end{center}
\end{figure}

\EXAMPLE{Example of vector clock-based causal
  broadcast.}{Figure~\ref{fig:vector} shows a broadcast protocol that ensures
  causal delivery by using vector clocks. When Process $p_1$ broadcasts its
  message $m$, it increments its entry in its vector clock and overloads the
  message with it: $m_{1,\,0,\,0}$. When Process $p_2$ receives the message, it
  checks if it is ready. It immediately delivers it, for the received vector is
  only 1 increment away from its own vector clock. Then Process $p_2$ broadcasts
  a message $m'$. It increments its own entry and overloads the message with its
  vector $[1,\,1,\,0]$. This acknowledges that the delivery of $m$ precedes the
  broadcast of $m'$. When Process $p_3$ receives the later, it detects that $m'$
  is not ready and delays it until it receives and delivers $m$. Then, $p_3$
  checks $m'$ again. $p_3$ finds that $m'$ is ready and delivers it. Using
  vector clocks, the message delivery order follows causal order.}


Another approach achieves causal delivery without overloading broadcast messages
with control information (\REF). It only assumes FIFO links and deterministic
overlay network (\REF). Processes deliver messages as soon as they arrive.

\begin{definition}[FIFO communication channel]
  If Process $p$ sends a message $m$ then $m'$ to Process $q$ using a FIFO
  channel, $q$ receives $m$ before $m'$.
\end{definition}

\begin{figure}
  \begin{center}
    \input{./input/figstatic.tex}
    \caption{\label{fig:static}FIFO channels are sufficient to provide causal
      order in static networks.}
  \end{center}
\end{figure}

\EXAMPLE{Example of FIFO-based causal broadcast.}{ Figure~\ref{fig:static} shows
  a broadcast protocol that ensures causal delivery by using FIFO channels.  The
  network is static and comprises 3 processes $p_1$, $p_2$, $p_3$ linked to each
  other. The figure does not show messages forwarded by $p_3$ for the sake of
  clarity.  The processes receive $m$ and $m'$ multiple times but there exists
  no link in the paths from $p_2$ to $p_3$ that carries $m'$ without having
  carried $m$ beforehand. Hence, the delivery of $m$ always precedes the
  delivery of $m'$ at any process.}


Unfortunately, this protocol ensures causal delivery only in static
networks. This does not hold in dynamic settings where processes can join the
network, or links can be added.

\begin{figure}
  \begin{center}
    \input{./input/figproblem.tex}
    \caption{\label{fig:problem}Adding FIFO links can cause causal order
      violations.}
  \end{center}
\end{figure}

\EXAMPLE{Example of FIFO-based causal broadcast in dynamic network.}{
  Figure~\ref{fig:problem} illustrates the issue with the establishment of new
  FIFO channels. In this example, a FIFO channel links $p_1$ to $p_2$; another
  links $p_2$ to $p_3$; none links $p_1$ to $p_3$. Other FIFO channels may exist
  but we do not show them for the sake of simplicity. Process $p_1$ broadcasts
  $m$ and delivers it. $p_3$ receives it by the intermediary of $p_2$. In the
  meantime, $p_1$ creates a FIFO channel to $p_3$, then broadcasts $m'$ to $p_2$
  and $p_3$. Since the path through $p_2$ is longer in terms of propagation time
  compared to the direct connections from $p_1$ to $p_3$, Process $p_3$ receives
  and delivers $m'$ before $m$. It violates causal order, for $m'$ precedes $m$.
}

In this paper, we introduce a causal broadcast protocol that
\begin{inparaenum}[(i)]
\item does not convey any control information in broadcast messages, and 
\item works in both static and dynamic networks.
\end{inparaenum}


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../paper"
%%% End:
