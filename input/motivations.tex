
\section{Background and motivations}
\label{sec:motivations}

Causal broadcast ensures that all connected processes deliver each broadcast
message exactly once~\cite{hadzilacos1994modular} following the happen before
relationship~\cite{lamport1978time}.

% \begin{figure*}
%   \begin{center}
%     \subfloat[Part A][\label{fig:generalproblemA}Process~A broadcasts $a$.]
%     {\input{input/figgeneralproblemA.tex}}
%     \hspace{20pt}
%     \subfloat[Part B][\label{fig:generalproblemB}Process~B receives and
%     delivers $a$ then broadcasts $b$.]
%     {\input{input/figgeneralproblemB.tex}}
%     \hspace{20pt}
%     \subfloat[Part C][\label{fig:generalproblemC}Process~C receives $b$
%     before $a$. The immediate delivery of $b$ violates causal order.]
%     {\input{input/figgeneralproblemC.tex}}
%     \caption{\label{fig:generalproblem}Causal order violation in network
%       without causal broadcast.}
%   \end{center}
% \end{figure*}


\begin{figure*}
  \begin{center}
    \subfloat[Part A][\label{fig:generalsolveA}Process~A broadcasts $a$.]
    {\input{input/figgeneralsolveA.tex}}
    \hspace{40pt}
    \subfloat[Part B][\label{fig:generalsolveB}Process~B receives and 
    delivers $a$. Process~B forwards $a$ using its FIFO links.]
    {\input{input/figgeneralsolveB.tex}}
    \hspace{40pt}
    \subfloat[Part C][\label{fig:generalsolveC}Process~B broadcasts $b$.]
    {\input{input/figgeneralsolveC.tex}}
    \\
    \subfloat[Part D][\label{fig:generalsolveD}Process~A receives and 
    delivers $b$. Process~A forwards $b$ using its FIFO links.]
    {\input{input/figgeneralsolveD.tex}}
    \hspace{40pt}
    \subfloat[Part E][\label{fig:generalsolveE}Process~C cannot receive $b$
    without having received $a$ beforehand.]
    {\input{input/figgeneralsolveE.tex}}
    \caption{\label{fig:generalsolve}Preventive broadcast ensures causal order.}
  \end{center}
\end{figure*}

% \begin{figure}
%   \begin{center}
%     \input{input/figgeneralsolveA.tex}
%     \caption{\label{fig:generalsolveA} Upon receipt of $a$, Process~B forwards
%       $a$ using FIFO links to all its neighbors. Process~C cannot receive $b$
%       without having received $a$ beforehand. It ensures causal delivery.}
%   \end{center}
% \end{figure}

\begin{figure*}
  \begin{center}
    \input{./input/figdisseminationtree.tex}
    \caption{\label{fig:disseminationtree}The principle of preventive causal
      broadcast works in large systems where processes have partial knowledge
      of the membership.}
  \end{center}
\end{figure*}

% Figure~\ref{fig:generalproblem} illustrates the need of an additional mechanism
% to ensure causal delivery of messages. It depicts a network comprising 3
% processes connected to each other. In Figure~\ref{fig:generalproblemA},
% Process~A broadcasts a message $a$, hence sends it to both Process~B and
% Process~C.  In Figure~\ref{fig:generalproblemB}, Process~B receives and delivers
% $a$ then broadcasts $b$. Causal order states that all processes of the network
% must deliver $a$ before $b$. However, in Figure~\ref{fig:generalproblemC}, we
% see that Process~C receives $b$ while $a$ is still traveling. Consequently, to
% ensure causal order Process~C must know on receipt of $b$ that it depends of
% another message $a$, an delay the delivery of $b$ until the receipt and delivery
% of $a$.

% This is the principle of reactive
% approaches~\cite{almeida2008interval,fidge1988timestamps,hadzilacos1993fault,mattern1989virtual,mostefaoui2017probabilistic,singhal1992efficient}.
% Table~\ref{table:comparison} shows the complexity of a vector clock-based
% representative~\cite{schwarz1994detecting}.  Each broadcast message conveys
% control information the size of which increases linearly with the number of
% processes. Each process must check at each receipt if the message is ready for
% causal delivery which takes linear time in terms of number of processes and
% number of messages delayed. Consequently, 
% % even if its operation works in dynamic
% %networks where membership changes over time, 
% it eventually becomes expensive and inefficient.

Instead of checking repeatedly if messages are ready to be delivered, a
preventive approach~\cite{friedman2004causal} makes sure that messages arrive
ready in the first place.  It uses FIFO links and systematically forwards
delivered messages.  Intuitively, the dissemination pattern automatically makes
sure that no path from a process to any other process carries messages out of
causal order.

Figure~\ref{fig:generalsolve} depicts the principle of the original preventive
approach. The system comprises 3 processes connected to each other with FIFO
links.  In Figure~\ref{fig:generalsolveA}, Process~A broadcasts $b$. It sends
$a$ to Process~B and Process~C. In Figure~\ref{fig:generalsolveB}, Process~B
receives, delivers, and forwards $a$. In Figure~\ref{fig:generalsolveC}, it
broadcasts $b$. Consequently, all processes must deliver $a$ before delivering
$b$. In Figure~\ref{fig:generalsolveD}, Process~A receives, delivers, and
forwards $b$. Process~A fulfills the causal order constraint between $a$ and
$b$. In Figure~\ref{fig:generalsolveE}, we see that either directly via
Process~B or indirectly via Process~A, Process~C cannot receive $b$ before
$a$. Thus, it eventually receives, delivers, and forwards the messages following
causal order.


In large systems, processes cannot afford to maintain the full membership to
communicate with. Instead, they have a much smaller view called
neighborhood. Forwarding messages allows them to reach all members of the
system, either directly or transitively in a gossip fashion (\REF). Forwarding
is mandatory for large scale systems.  Whatever the broadcast protocol,
processes pay the price of gossiping. They must create and send copies of the
original broadcast message. Preventive broadcast operation requires forwarding
but since gossiping already forwards messages, it does not constitute an
additional overhead of the approach.

Figure~\ref{fig:disseminationtree} shows that preventive broadcast ensures
causal order in larger systems where processes have limited knowledge of
the membership.  Process~A only knows about Process~C and Process~D.  Yet,
Process~A's broadcast messages $a$ and $a'$ arrive to all other processes either
directly or transitively. In addition, $a$ and $a'$ always arrive in causal
order at all processes despite concurrency and whatever the dissemination path.

% Figure~\ref{fig:disseminationtree} shows an example of message
% dissemination. Process~A broadcasts $a$ then $a'$. All processes must receive
% $a$ before $a'$. Process~A sends it to the network using all its
% links. Process~B and Process~C necessarily receive $a$ before $a'$ for links are
% FIFO. They forward these messages in FIFO order using all their links too.
% Other processes necessarily receive $a$ before $a'$ for no subsequent path will
% ever carry $a'$ before $a$.  We see that in spite of concurrent messages
% broadcast at different time, Process~F always receives $a$ before
% $a'$. Concurrent messages also have causal relationship to ensure.  Since
% Process~B broadcasts $b$ right after it received $a$, all processes must receive
% $a$ before $b$. Since Process~C broadcasts $c$ after the receipt of $a'$, all
% processes must receive $c$ after $a'$, hence after $a$. However, there is no
% constraint between message deliveries of $c$ and $b$. Process~F can receive them
% in any order.


%On the opposite, second row of 
% Table~\ref{table:comparison} shows the complexity of a preventive
% approach~\cite{friedman2004causal}. It outperforms the reactive approach:
% message overhead is constant; it safely prunes its local structure; message
% delivery time is constant.


\begin{figure*}
  \begin{center}
    \subfloat[Part 1][\label{fig:preventiveproblemA}Process~A broadcasts $a$.]
    {\input{input/figpreventiveproblemA.tex}}
    \hspace{20pt}
    \subfloat[Part 2][\label{fig:preventiveproblemA2}Process~A adds a link 
    to Process~D.]
    {\input{input/figpreventiveproblemA2.tex}}
    \hspace{20pt}
    \subfloat[Part 3][\label{fig:preventiveproblemB}Process~A broadcasts $a'$.]
    {\input{input/figpreventiveproblemB.tex}}
    \hspace{20pt}
    \subfloat[Part 4][\label{fig:preventiveproblemC}Process~D receives and
    delivers $a'$ before $a$. This violates causal order.]
    {\input{input/figpreventiveproblemC.tex}}
    \hspace{20pt}
    \subfloat[Part 4][\label{fig:preventiveproblemD}Process~D propagates
    the causal order violation.]
    {\input{input/figpreventiveproblemD.tex}}
    \caption{\label{fig:preventiveproblem}Preventive causal broadcast may
      violate causal order in dynamic settings.}
  \end{center}
\end{figure*}


Unfortunately, the original preventive causal broadcast protocol ensures causal
order only in static systems where the membership does not change and no links
are added or removed~\cite{friedman2004causal}. These are not practical
assumptions.  In practice, processes may join and leave the system at any time;
and processes may reconfigure their neighborhood at any time.
Figure~\ref{fig:preventiveproblem} shows an example of message dissemination in
dynamic settings where causal delivery is violated. In
Figure~\ref{fig:preventiveproblemA}, Process~A broadcasts $a$. It sends $a$ to
all its neighbors. Here, it sends $a$ to Process~B only.  Afterwards, in
Figure~\ref{fig:preventiveproblemA2}, Process~A adds a link to
Process~D. Message $a$ is still traveling. In particular, it did not reach
Process~D yet. In Figure~\ref{fig:preventiveproblemB}, Process~A broadcasts
$a'$. In this example, messages travel faster using the direct link from A to D
than using B as intermediate.  We see in Figure~\ref{fig:preventiveproblemC}
that $a'$ arrives at Process~D before $a$. Figure~\ref{fig:preventiveproblemD}
shows that not only it violates causal delivery but also propagates the
violation to all processes downstream.

% A preventive causal broadcast ensuring causal delivery at marginal cost and that
% \item handles both static and dynamic networks,
% \end{inparaenum}
% would finally make causal broadcast \TODO{safe}, affordable and efficient in
% large and dynamic systems.

% \begin{figure}
%   \begin{center}
%     \input{./input/figproblem.tex}
%     \caption{\label{fig:problem}Preventive broadcast in dynamic network.}
%   \end{center}
% \end{figure}

% \EXAMPLE{Example of preventive approach in dynamic network.}{
%   Figure~\ref{fig:problem} illustrates the issue with the establishment of new
%   FIFO channels. In this example, a FIFO channel links $p_1$ to $p_2$; another
%   links $p_2$ to $p_3$; none links $p_1$ to $p_3$. Other FIFO channels may exist
%   but we do not show them for the sake of simplicity. Process $p_1$ broadcasts
%   $m$ and delivers it. $p_3$ receives it by the intermediary of $p_2$. In the
%   meantime, $p_1$ creates a FIFO channel to $p_3$, then broadcasts $m'$ to $p_2$
%   and $p_3$. Since the path through $p_2$ is longer in terms of propagation time
%   compared to the direct connections from $p_1$ to $p_3$, Process $p_3$ receives
%   and delivers $m'$ before $m$. It violates causal order, for $m'$ precedes $m$.
% }

The causal broadcast presented in this paper is preventive and solves the causal
order violation issue of dynamic systems.  Table~\ref{table:comparison} shows
its complexity. Similarly to the preventive approach, complexity stays constant
in terms of message overhead and message delivery time. The local space
complexity is linear in terms of number of processes. We conjecture that this
bound is minimal in dynamic settings. In addition, our algorithm employs another
local structure to ensure causal order but we show that we can bound it in
Algorithm~\ref{algo:boundingbuffer}. This makes causal broadcast affordable and
efficient even in large and dynamic systems.

Next section describes our preventive causal broadcast for large and dynamic
systems. It details its operation, provides the proofs that it works in both
static and dynamic settings, and shows its complexity analysis.



%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../paper"
%%% End:
