
\section{Background and motivations}
\label{sec:motivations}

Broadcast protocols ensure that all connected processes receive and deliver each
broadcast message~\cite{hadzilacos1994modular}. Applications often require more
guarantees on message delivery to ensure consistency criteria (\REF). We focus
on guaranteeing causal order on message delivery: messages must be delivered
following the happen before relationship~\cite{lamport1978time}.

\begin{figure*}
  \begin{center}
    \subfloat[Part A][\label{fig:generalproblemA}Process~A broadcasts $a$.]
    {\input{input/figgeneralproblemA.tex}}
    \hspace{20pt}
    \subfloat[Part B][\label{fig:generalproblemB}Process~B receives and
    delivers $a$ then broadcasts $b$.]
    {\input{input/figgeneralproblemB.tex}}
    \hspace{20pt}
    \subfloat[Part C][\label{fig:generalproblemC}Process~C receives $b$
    before $a$. The immediate delivery of $b$ violates causal order.]
    {\input{input/figgeneralproblemC.tex}}
    \caption{\label{fig:generalproblem}Causal order violation in network
      without causal broadcast.}
  \end{center}
\end{figure*}


\begin{figure}
  \begin{center}
    \input{input/figgeneralsolveA.tex}
    \caption{\label{fig:generalsolveA} Upon receipt of $a$, Process~B forwards
      $a$ using FIFO links to all its neighbors. Process~C cannot receive $b$
      without having received $a$ beforehand. It ensures causal delivery.}
  \end{center}
\end{figure}

\begin{figure*}
  \begin{center}
    \input{./input/figdisseminationtree.tex}
    \caption{\label{fig:disseminationtree}The principle of preventive causal
      broadcast works in large networks where processes have partial knowledge
      of the network membership.}
  \end{center}
\end{figure*}

Figure~\ref{fig:generalproblem} illustrates the need of an additional mechanism
to ensure causal delivery of messages. It depicts a network comprising 3
processes connected to each other. In Figure~\ref{fig:generalproblemA},
Process~A broadcasts a message $a$, hence sends it to both Process~B and
Process~C.  In Figure~\ref{fig:generalproblemB}, Process~B receives and delivers
$a$ then broadcasts $b$. Causal order states that all processes of the network
must deliver $a$ before $b$. However, in Figure~\ref{fig:generalproblemC}, we
see that Process~C receives $b$ while $a$ is still traveling. Consequently, to
ensure causal order Process~C must know on receipt of $b$ that it depends of
another message $a$, an delay the delivery of $b$ until the receipt and delivery
of $a$.

\begin{table}
  \caption{\label{table:comparison} Space and time complexity of causal
    broadcast protocols. 
    $N$ is the number of processes. 
    $W$ is the number of messages received but waiting to be delivered.
    $P$ is the number of messages that are not yet purged.
    $B$ is the size of a set of temporary buffers.}
  \input{input/tableoverlayvstimestamp.tex}
\end{table}

This is the principle of reactive
approaches~\cite{almeida2008interval,fidge1988timestamps,hadzilacos1993fault,mattern1989virtual,mostefaoui2017probabilistic,singhal1992efficient}.
Table~\ref{table:comparison} shows the complexity of a vector clock-based
representative~\cite{schwarz1994detecting}.  Each broadcast message conveys
control information the size of which increases linearly with the number of
processes. Each process must check at each receipt if the message is ready for
causal delivery which takes linear time in terms of number of processes and
number of messages delayed. Consequently, 
% even if its operation works in dynamic
%networks where membership changes over time, 
it eventually becomes expensive and inefficient.

Instead of checking repeatedly if messages are ready to be delivered, a
preventive approach~\cite{friedman2004causal} makes sure that messages arrive
ready in the first place. Intuitively, the dissemination pattern automatically
makes sure that no path from a process to any other process carries messages out
of causal order. It uses FIFO links and systematically forwards delivered
messages. Figure~\ref{fig:generalsolveA} shows that when Process~B receives and
delivers $a$, it forwards $a$ to Process~A and process~C. Then it broadcasts
$b$. Whatever the communication link, $b$ follows $a$. Thus, Process~C always
receives and delivers $a$ before $b$.

Figure~\ref{fig:disseminationtree} shows that preventive broadcast ensures
causal order in larger networks. In large network, processes cannot afford to
maintain the full network membership to communicate with. Instead, they have a
much smaller view called neighborhood. Forwarding messages allows them to reach
all members of the network, either directly or transitively in a gossip fashion
(\REF). Thus, forwarding is already mandatory for large scale networks and does
not constitute an overhead of preventive approaches.
Figure~\ref{fig:disseminationtree} shows that Process~A's broadcast messages $a$
and $a'$ always arrive in causal order at all processes despite concurrency and
whatever the dissemination path.

% Figure~\ref{fig:disseminationtree} shows an example of message
% dissemination. Process~A broadcasts $a$ then $a'$. All processes must receive
% $a$ before $a'$. Process~A sends it to the network using all its
% links. Process~B and Process~C necessarily receive $a$ before $a'$ for links are
% FIFO. They forward these messages in FIFO order using all their links too.
% Other processes necessarily receive $a$ before $a'$ for no subsequent path will
% ever carry $a'$ before $a$.  We see that in spite of concurrent messages
% broadcast at different time, Process~F always receives $a$ before
% $a'$. Concurrent messages also have causal relationship to ensure.  Since
% Process~B broadcasts $b$ right after it received $a$, all processes must receive
% $a$ before $b$. Since Process~C broadcasts $c$ after the receipt of $a'$, all
% processes must receive $c$ after $a'$, hence after $a$. However, there is no
% constraint between message deliveries of $c$ and $b$. Process~F can receive them
% in any order.


%On the opposite, second row of 
Table~\ref{table:comparison} shows the complexity of a preventive
approach~\cite{friedman2004causal}. It outperforms the reactive approach:
message overhead is constant; it safely prunes its local structure; message
delivery time is constant.


\begin{figure*}
  \begin{center}
    \subfloat[Part 1][\label{fig:preventiveproblemA}Process~A broadcasts $a$.]
    {\input{input/figpreventiveproblemA.tex}}
    \hspace{20pt}
    \subfloat[Part 2][\label{fig:preventiveproblemA2}Process~A adds a link 
    to Process~D.]
    {\input{input/figpreventiveproblemA2.tex}}
    \hspace{20pt}
    \subfloat[Part 3][\label{fig:preventiveproblemB}Process~A broadcasts $a'$.]
    {\input{input/figpreventiveproblemB.tex}}
    \hspace{20pt}
    \subfloat[Part 4][\label{fig:preventiveproblemC}Process~D receives and
    delivers $a'$ before $a$. This violates causal order.]
    {\input{input/figpreventiveproblemC.tex}}
    \hspace{20pt}
    \subfloat[Part 4][\label{fig:preventiveproblemD}Process~D propagates
    the causal order violation.]
    {\input{input/figpreventiveproblemD.tex}}
    \caption{\label{fig:preventiveproblem}Preventive causal broadcast may
      violate causal order in dynamic settings.}
  \end{center}
\end{figure*}


However, the latter holds only in static networks where the membership does not
change and no links are added nor removed~\cite{friedman2004causal}. These are
not practical assumptions.  In practice, processes may join and leave the
network at any time; and processes may reconfigure their neighborhood at any
time.  Figure~\ref{fig:preventiveproblem} shows an example of message
dissemination in dynamic settings where causal delivery is violated. In
Figure~\ref{fig:preventiveproblemA}, Process~A broadcasts $a$. It sends $a$ to
all its neighbors. Here, it sends $a$ to Process~B only.  Afterwards, in
Figure~\ref{fig:preventiveproblemA2}, Process~A adds a link to
Process~D. Message $a$ is still traveling in the network. In particular, it did
not reach Process~D yet. In Figure~\ref{fig:preventiveproblemB}, Process~A
broadcasts $a'$. In this example, messages travel faster using the direct link
from A to D than using B as intermediate.  We see in
Figure~\ref{fig:preventiveproblemC} that $a'$ arrives at Process~D before
$a$. Figure~\ref{fig:preventiveproblemD} shows that not only it violates causal
delivery but also propagates the violation to all processes downstream.

% A preventive causal broadcast ensuring causal delivery at marginal cost and that
% \item handles both static and dynamic networks,
% \end{inparaenum}
% would finally make causal broadcast \TODO{safe}, affordable and efficient in
% large and dynamic systems.

% \begin{figure}
%   \begin{center}
%     \input{./input/figproblem.tex}
%     \caption{\label{fig:problem}Preventive broadcast in dynamic network.}
%   \end{center}
% \end{figure}

% \EXAMPLE{Example of preventive approach in dynamic network.}{
%   Figure~\ref{fig:problem} illustrates the issue with the establishment of new
%   FIFO channels. In this example, a FIFO channel links $p_1$ to $p_2$; another
%   links $p_2$ to $p_3$; none links $p_1$ to $p_3$. Other FIFO channels may exist
%   but we do not show them for the sake of simplicity. Process $p_1$ broadcasts
%   $m$ and delivers it. $p_3$ receives it by the intermediary of $p_2$. In the
%   meantime, $p_1$ creates a FIFO channel to $p_3$, then broadcasts $m'$ to $p_2$
%   and $p_3$. Since the path through $p_2$ is longer in terms of propagation time
%   compared to the direct connections from $p_1$ to $p_3$, Process $p_3$ receives
%   and delivers $m'$ before $m$. It violates causal order, for $m'$ precedes $m$.
% }

The causal broadcast presented in this paper is preventive and solves the causal
order violation issue of dynamic networks.  Table~\ref{table:comparison} shows
its complexity. Similarly to the preventive approach, complexity stays constant
in terms of message overhead and message delivery time. The local space
complexity is linear in terms of number of processes. We conjecture that this
bound is minimal in dynamic settings. In addition, our algorithm employs another
local structure to ensure causal order but we show that we can bound it in
Algorithm~\ref{algo:boundingbuffer}. This makes causal broadcast affordable and
efficient even in large and dynamic networks.

Next section describes our preventive causal broadcast for large and dynamic
networks. It details its operation, provides the proofs that it works in both
static and dynamic settings, and shows its complexity analysis.



%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../paper"
%%% End:
