
\section{Related work}
\label{sec:relatedwork}

\TODO{Table comparing the improvement. Local overhead. Number of
  messages. Message overhead.}

\paragraph{Piggybacking messages~\cite{birman1987reliable,hadzilacos1993fault}.}
A trivial way to ensure causal ordering of messages is to piggyback all causally
related messages since the last broadcast message along with the newly broadcast
message. Similarly to our approach, these broadcast protocols can deliver
messages as soon as they arrive.  However, even by piggybacking the identifiers
of messages instead of messages themselves, the broadcast message size may
increase quickly depending on the application. In our approach, a similar
behavior arises during buffering. However, we assume that the time between the
establishment of a link and its actual usage remains short. For instance, using
a random peer-sampling protocol in WebRTC such as Spray or Cyclon allows us to
create a 3-hops protocol for these acknowledgements. In addition, as discussed
in Section \TODO{meow}, the size of buffers can be trivially
bounded. \TODO{Maybe discuss all of this in proposal (3-hops protocol).}

\paragraph{Vector clock-based
  approaches~\cite{fidge1988timestamps,mattern1989virtual}.} A vector clock is a
vector of monotonically increasing counters.
$VC(m) < VC(m') \implies m \rightarrow m'$ +compaction.

\paragraph{Topological constraint-based approaches.} Ring-based. 

\paragraph{Inter-group
  broadcast~\cite{johnson1998scalable,johnson1999intergroup}.} Inter-group
broadcast allows processes to broadcast messages to members of several
inter-connected networks. Paper~\cite{johnson1999intergroup} states that
inter-group causal broadcast is ensured when groups that internally ensure
causal broadcast are linked together by communication channels that ensure FIFO
ordering of messages. Our approach is an extreme case where each process is a
group connected to other groups via FIFO channels. The union of paths taken by
broadcast messages builds a diffusion tree, i.e., an acyclic graph, that may
change at each broadcast.

\paragraph{Already received.} Causal ordering and detecting duplicated receipts
are orthogonal problems. In this paper, we do not provide an implementation for
the later. The simplest approach consists in saving all received messages
(\REF). However, the size of this set linearly and monotonically increases as
the number of broadcast messages increases. One would prefer an approach based
on vectors where one entry corresponds to the number of messages received by a
particular process (\REF). Such approach do not require to piggyback additional
data in the message. However, it requires to store locally a vector the size of
which increases linearly compared to the number of processes that ever broadcast
a message. Interval tree clocks (\REF) allow processes to reduce this
complexity. It becomes linear in terms of number of processes that are currently
involved in broadcasting. Possible improvements could take advantage of the fact
that the number of duplicates is equal to the number of incoming links. However,
it does not hold in dynamic networks where additional links are
established. Finding a sublinear bound for detecting duplicated receipts remains
an open problem.


\paragraph{Push-pull.} Pull is optimally fast. Push phase of push-pull improves
the startup phase of message dissemination. We only present push but it easily
can be push-pull.


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../paper"
%%% End:
